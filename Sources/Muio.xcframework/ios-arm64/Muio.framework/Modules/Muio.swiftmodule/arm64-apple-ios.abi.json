{
  "ABIRoot": {
    "kind": "Root",
    "name": "TopLevel",
    "printedName": "TopLevel",
    "children": [
      {
        "kind": "Import",
        "name": "MetalKit",
        "printedName": "MetalKit",
        "declKind": "Import",
        "moduleName": "Muio",
        "declAttributes": [
          "RawDocComment"
        ]
      },
      {
        "kind": "Import",
        "name": "SceneKit",
        "printedName": "SceneKit",
        "declKind": "Import",
        "moduleName": "Muio"
      },
      {
        "kind": "Import",
        "name": "CoreMedia",
        "printedName": "CoreMedia",
        "declKind": "Import",
        "moduleName": "Muio"
      },
      {
        "kind": "Import",
        "name": "MobileCoreServices",
        "printedName": "MobileCoreServices",
        "declKind": "Import",
        "moduleName": "Muio"
      },
      {
        "kind": "Import",
        "name": "UniformTypeIdentifiers",
        "printedName": "UniformTypeIdentifiers",
        "declKind": "Import",
        "moduleName": "Muio"
      },
      {
        "kind": "TypeDecl",
        "name": "MetalDevice",
        "printedName": "MetalDevice",
        "children": [
          {
            "kind": "Var",
            "name": "shared",
            "printedName": "shared",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "MetalDevice",
                "printedName": "Muio.MetalDevice",
                "usr": "s:4Muio11MetalDeviceC"
              }
            ],
            "declKind": "Var",
            "usr": "s:4Muio11MetalDeviceC6sharedACvpZ",
            "mangledName": "$s4Muio11MetalDeviceC6sharedACvpZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "HasInitialValue",
              "Final",
              "HasStorage",
              "AccessControl"
            ],
            "isLet": true,
            "hasStorage": true,
            "accessors": [
              {
                "kind": "Accessor",
                "name": "Get",
                "printedName": "Get()",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MetalDevice",
                    "printedName": "Muio.MetalDevice",
                    "usr": "s:4Muio11MetalDeviceC"
                  }
                ],
                "declKind": "Accessor",
                "usr": "s:4Muio11MetalDeviceC6sharedACvgZ",
                "mangledName": "$s4Muio11MetalDeviceC6sharedACvgZ",
                "moduleName": "Muio",
                "static": true,
                "implicit": true,
                "declAttributes": [
                  "Final"
                ],
                "accessorKind": "get"
              }
            ]
          },
          {
            "kind": "Var",
            "name": "device",
            "printedName": "device",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "MTLDevice",
                "printedName": "any Metal.MTLDevice",
                "usr": "c:objc(pl)MTLDevice"
              }
            ],
            "declKind": "Var",
            "usr": "s:4Muio11MetalDeviceC6deviceSo9MTLDevice_pvp",
            "mangledName": "$s4Muio11MetalDeviceC6deviceSo9MTLDevice_pvp",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "HasStorage",
              "AccessControl"
            ],
            "isLet": true,
            "hasStorage": true,
            "accessors": [
              {
                "kind": "Accessor",
                "name": "Get",
                "printedName": "Get()",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLDevice",
                    "printedName": "any Metal.MTLDevice",
                    "usr": "c:objc(pl)MTLDevice"
                  }
                ],
                "declKind": "Accessor",
                "usr": "s:4Muio11MetalDeviceC6deviceSo9MTLDevice_pvg",
                "mangledName": "$s4Muio11MetalDeviceC6deviceSo9MTLDevice_pvg",
                "moduleName": "Muio",
                "implicit": true,
                "declAttributes": [
                  "Final"
                ],
                "accessorKind": "get"
              }
            ]
          },
          {
            "kind": "Var",
            "name": "commandQueue",
            "printedName": "commandQueue",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "MTLCommandQueue",
                "printedName": "any Metal.MTLCommandQueue",
                "usr": "c:objc(pl)MTLCommandQueue"
              }
            ],
            "declKind": "Var",
            "usr": "s:4Muio11MetalDeviceC12commandQueueSo010MTLCommandE0_pvp",
            "mangledName": "$s4Muio11MetalDeviceC12commandQueueSo010MTLCommandE0_pvp",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "HasStorage",
              "AccessControl"
            ],
            "isLet": true,
            "hasStorage": true,
            "accessors": [
              {
                "kind": "Accessor",
                "name": "Get",
                "printedName": "Get()",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLCommandQueue",
                    "printedName": "any Metal.MTLCommandQueue",
                    "usr": "c:objc(pl)MTLCommandQueue"
                  }
                ],
                "declKind": "Accessor",
                "usr": "s:4Muio11MetalDeviceC12commandQueueSo010MTLCommandE0_pvg",
                "mangledName": "$s4Muio11MetalDeviceC12commandQueueSo010MTLCommandE0_pvg",
                "moduleName": "Muio",
                "implicit": true,
                "declAttributes": [
                  "Final"
                ],
                "accessorKind": "get"
              }
            ]
          },
          {
            "kind": "Var",
            "name": "videoTextureCache",
            "printedName": "videoTextureCache",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "CoreVideo.CVMetalTextureCache?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CVMetalTextureCache",
                    "printedName": "CoreVideo.CVMetalTextureCache",
                    "usr": "c:@T@CVMetalTextureCacheRef"
                  }
                ],
                "usr": "s:Sq"
              }
            ],
            "declKind": "Var",
            "usr": "s:4Muio11MetalDeviceC17videoTextureCacheSo07CVMetaleF3RefaSgvp",
            "mangledName": "$s4Muio11MetalDeviceC17videoTextureCacheSo07CVMetaleF3RefaSgvp",
            "moduleName": "Muio",
            "declAttributes": [
              "HasInitialValue",
              "HasStorage",
              "AccessControl"
            ],
            "hasStorage": true,
            "accessors": [
              {
                "kind": "Accessor",
                "name": "Get",
                "printedName": "Get()",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Optional",
                    "printedName": "CoreVideo.CVMetalTextureCache?",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "CVMetalTextureCache",
                        "printedName": "CoreVideo.CVMetalTextureCache",
                        "usr": "c:@T@CVMetalTextureCacheRef"
                      }
                    ],
                    "usr": "s:Sq"
                  }
                ],
                "declKind": "Accessor",
                "usr": "s:4Muio11MetalDeviceC17videoTextureCacheSo07CVMetaleF3RefaSgvg",
                "mangledName": "$s4Muio11MetalDeviceC17videoTextureCacheSo07CVMetaleF3RefaSgvg",
                "moduleName": "Muio",
                "implicit": true,
                "accessorKind": "get"
              },
              {
                "kind": "Accessor",
                "name": "Set",
                "printedName": "Set()",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Void",
                    "printedName": "()"
                  },
                  {
                    "kind": "TypeNominal",
                    "name": "Optional",
                    "printedName": "CoreVideo.CVMetalTextureCache?",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "CVMetalTextureCache",
                        "printedName": "CoreVideo.CVMetalTextureCache",
                        "usr": "c:@T@CVMetalTextureCacheRef"
                      }
                    ],
                    "usr": "s:Sq"
                  }
                ],
                "declKind": "Accessor",
                "usr": "s:4Muio11MetalDeviceC17videoTextureCacheSo07CVMetaleF3RefaSgvs",
                "mangledName": "$s4Muio11MetalDeviceC17videoTextureCacheSo07CVMetaleF3RefaSgvs",
                "moduleName": "Muio",
                "implicit": true,
                "accessorKind": "set"
              },
              {
                "kind": "Accessor",
                "name": "Modify",
                "printedName": "Modify()",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Void",
                    "printedName": "()"
                  }
                ],
                "declKind": "Accessor",
                "usr": "s:4Muio11MetalDeviceC17videoTextureCacheSo07CVMetaleF3RefaSgvM",
                "mangledName": "$s4Muio11MetalDeviceC17videoTextureCacheSo07CVMetaleF3RefaSgvM",
                "moduleName": "Muio",
                "implicit": true,
                "accessorKind": "_modify"
              }
            ]
          },
          {
            "kind": "Function",
            "name": "allocTextureCache",
            "printedName": "allocTextureCache()",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Void",
                "printedName": "()"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC17allocTextureCacheyyF",
            "mangledName": "$s4Muio11MetalDeviceC17allocTextureCacheyyF",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "newCommandBuffer",
            "printedName": "newCommandBuffer()",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "MTLCommandBuffer",
                "printedName": "any Metal.MTLCommandBuffer",
                "usr": "c:objc(pl)MTLCommandBuffer"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC16newCommandBufferSo010MTLCommandF0_pyF",
            "mangledName": "$s4Muio11MetalDeviceC16newCommandBufferSo010MTLCommandF0_pyF",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "renderPipe",
            "printedName": "renderPipe(vertexFunctionName:fragmentFunctionName:pixelFormat:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "MTLRenderPipelineState",
                "printedName": "any Metal.MTLRenderPipelineState",
                "usr": "c:objc(pl)MTLRenderPipelineState"
              },
              {
                "kind": "TypeNominal",
                "name": "String",
                "printedName": "Swift.String",
                "hasDefaultArg": true,
                "usr": "s:SS"
              },
              {
                "kind": "TypeNominal",
                "name": "String",
                "printedName": "Swift.String",
                "usr": "s:SS"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLPixelFormat",
                "printedName": "Metal.MTLPixelFormat",
                "usr": "c:@E@MTLPixelFormat"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC10renderPipe18vertexFunctionName08fragmentgH011pixelFormatSo22MTLRenderPipelineState_pSS_SSSo08MTLPixelK0VtKFZ",
            "mangledName": "$s4Muio11MetalDeviceC10renderPipe18vertexFunctionName08fragmentgH011pixelFormatSo22MTLRenderPipelineState_pSS_SSSo08MTLPixelK0VtKFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "throwing": true,
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "texture",
            "printedName": "texture(_:pixelFormat:_:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLTexture)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLTexture",
                    "printedName": "any Metal.MTLTexture",
                    "usr": "c:objc(pl)MTLTexture"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "CGSize",
                "printedName": "CoreFoundation.CGSize",
                "usr": "c:@S@CGSize"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLPixelFormat",
                "printedName": "Metal.MTLPixelFormat",
                "hasDefaultArg": true,
                "usr": "c:@E@MTLPixelFormat"
              },
              {
                "kind": "TypeNominal",
                "name": "String",
                "printedName": "Swift.String",
                "hasDefaultArg": true,
                "usr": "s:SS"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC7texture_11pixelFormat_So10MTLTexture_pSgSo6CGSizeV_So08MTLPixelF0VSStFZ",
            "mangledName": "$s4Muio11MetalDeviceC7texture_11pixelFormat_So10MTLTexture_pSgSo6CGSizeV_So08MTLPixelF0VSStFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "textureRead",
            "printedName": "textureRead(_:pixelFormat:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLTexture)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLTexture",
                    "printedName": "any Metal.MTLTexture",
                    "usr": "c:objc(pl)MTLTexture"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "CGSize",
                "printedName": "CoreFoundation.CGSize",
                "usr": "c:@S@CGSize"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLPixelFormat",
                "printedName": "Metal.MTLPixelFormat",
                "hasDefaultArg": true,
                "usr": "c:@E@MTLPixelFormat"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC11textureRead_11pixelFormatSo10MTLTexture_pSgSo6CGSizeV_So08MTLPixelG0VtFZ",
            "mangledName": "$s4Muio11MetalDeviceC11textureRead_11pixelFormatSo10MTLTexture_pSgSo6CGSizeV_So08MTLPixelG0VtFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "textureA",
            "printedName": "textureA(_:_:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLTexture)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLTexture",
                    "printedName": "any Metal.MTLTexture",
                    "usr": "c:objc(pl)MTLTexture"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "Int",
                "printedName": "Swift.Int",
                "usr": "s:Si"
              },
              {
                "kind": "TypeNominal",
                "name": "Int",
                "printedName": "Swift.Int",
                "usr": "s:Si"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC8textureAySo10MTLTexture_pSgSi_SitFZ",
            "mangledName": "$s4Muio11MetalDeviceC8textureAySo10MTLTexture_pSgSi_SitFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "filerTexture",
            "printedName": "filerTexture(_:_:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLTexture)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLTexture",
                    "printedName": "any Metal.MTLTexture",
                    "usr": "c:objc(pl)MTLTexture"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "Int",
                "printedName": "Swift.Int",
                "usr": "s:Si"
              },
              {
                "kind": "TypeNominal",
                "name": "Int",
                "printedName": "Swift.Int",
                "usr": "s:Si"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC12filerTextureySo10MTLTexture_pSgSi_SitFZ",
            "mangledName": "$s4Muio11MetalDeviceC12filerTextureySo10MTLTexture_pSgSi_SitFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "vertexBuffer",
            "printedName": "vertexBuffer()",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLBuffer)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLBuffer",
                    "printedName": "any Metal.MTLBuffer",
                    "usr": "c:objc(pl)MTLBuffer"
                  }
                ],
                "usr": "s:Sq"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC12vertexBufferSo9MTLBuffer_pSgyFZ",
            "mangledName": "$s4Muio11MetalDeviceC12vertexBufferSo9MTLBuffer_pSgyFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "faceBuffer",
            "printedName": "faceBuffer(faceFloats:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLBuffer)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLBuffer",
                    "printedName": "any Metal.MTLBuffer",
                    "usr": "c:objc(pl)MTLBuffer"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "Array",
                "printedName": "[Swift.SIMD2<Swift.Float>]",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "SIMD2",
                    "printedName": "Swift.SIMD2<Swift.Float>",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "Float",
                        "printedName": "Swift.Float",
                        "usr": "s:Sf"
                      }
                    ],
                    "usr": "s:s5SIMD2V"
                  }
                ],
                "usr": "s:Sa"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC10faceBuffer0D6FloatsSo9MTLBuffer_pSgSays5SIMD2VySfGG_tFZ",
            "mangledName": "$s4Muio11MetalDeviceC10faceBuffer0D6FloatsSo9MTLBuffer_pSgSays5SIMD2VySfGG_tFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Var",
            "name": "index_data",
            "printedName": "index_data",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Array",
                "printedName": "[Swift.UInt16]",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "UInt16",
                    "printedName": "Swift.UInt16",
                    "usr": "s:s6UInt16V"
                  }
                ],
                "usr": "s:Sa"
              }
            ],
            "declKind": "Var",
            "usr": "s:4Muio11MetalDeviceC10index_dataSays6UInt16VGvp",
            "mangledName": "$s4Muio11MetalDeviceC10index_dataSays6UInt16VGvp",
            "moduleName": "Muio",
            "declAttributes": [
              "HasInitialValue",
              "Final",
              "HasStorage",
              "AccessControl"
            ],
            "isLet": true,
            "hasStorage": true,
            "accessors": [
              {
                "kind": "Accessor",
                "name": "Get",
                "printedName": "Get()",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Array",
                    "printedName": "[Swift.UInt16]",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "UInt16",
                        "printedName": "Swift.UInt16",
                        "usr": "s:s6UInt16V"
                      }
                    ],
                    "usr": "s:Sa"
                  }
                ],
                "declKind": "Accessor",
                "usr": "s:4Muio11MetalDeviceC10index_dataSays6UInt16VGvg",
                "mangledName": "$s4Muio11MetalDeviceC10index_dataSays6UInt16VGvg",
                "moduleName": "Muio",
                "implicit": true,
                "declAttributes": [
                  "Final"
                ],
                "accessorKind": "get"
              }
            ]
          },
          {
            "kind": "Function",
            "name": "renderPipe",
            "printedName": "renderPipe(vertexFunctionName:fragmentFunctionName:pixelFormat:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "MTLRenderPipelineState",
                "printedName": "any Metal.MTLRenderPipelineState",
                "usr": "c:objc(pl)MTLRenderPipelineState"
              },
              {
                "kind": "TypeNominal",
                "name": "String",
                "printedName": "Swift.String",
                "hasDefaultArg": true,
                "usr": "s:SS"
              },
              {
                "kind": "TypeNominal",
                "name": "String",
                "printedName": "Swift.String",
                "usr": "s:SS"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLPixelFormat",
                "printedName": "Metal.MTLPixelFormat",
                "usr": "c:@E@MTLPixelFormat"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC10renderPipe18vertexFunctionName08fragmentgH011pixelFormatSo22MTLRenderPipelineState_pSS_SSSo08MTLPixelK0VtKF",
            "mangledName": "$s4Muio11MetalDeviceC10renderPipe18vertexFunctionName08fragmentgH011pixelFormatSo22MTLRenderPipelineState_pSS_SSSo08MTLPixelK0VtKF",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "throwing": true,
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "faceIndexBuffer",
            "printedName": "faceIndexBuffer(faceFloats:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLBuffer)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLBuffer",
                    "printedName": "any Metal.MTLBuffer",
                    "usr": "c:objc(pl)MTLBuffer"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "Array",
                "printedName": "[Swift.SIMD2<Swift.Float>]",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "SIMD2",
                    "printedName": "Swift.SIMD2<Swift.Float>",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "Float",
                        "printedName": "Swift.Float",
                        "usr": "s:Sf"
                      }
                    ],
                    "usr": "s:s5SIMD2V"
                  }
                ],
                "usr": "s:Sa"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC15faceIndexBuffer0D6FloatsSo9MTLBuffer_pSgSays5SIMD2VySfGG_tFZ",
            "mangledName": "$s4Muio11MetalDeviceC15faceIndexBuffer0D6FloatsSo9MTLBuffer_pSgSays5SIMD2VySfGG_tFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "cVTexture",
            "printedName": "cVTexture(buffer:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLTexture)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLTexture",
                    "printedName": "any Metal.MTLTexture",
                    "usr": "c:objc(pl)MTLTexture"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "CoreVideo.CVBuffer?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CVBuffer",
                    "printedName": "CoreVideo.CVBuffer",
                    "usr": "c:@T@CVBufferRef"
                  }
                ],
                "usr": "s:Sq"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC9cVTexture6bufferSo10MTLTexture_pSgSo11CVBufferRefaSg_tF",
            "mangledName": "$s4Muio11MetalDeviceC9cVTexture6bufferSo10MTLTexture_pSgSo11CVBufferRefaSg_tF",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "ciTexture",
            "printedName": "ciTexture(_:size:pixelFormat:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLTexture)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLTexture",
                    "printedName": "any Metal.MTLTexture",
                    "usr": "c:objc(pl)MTLTexture"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "CoreImage.CIImage?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CIImage",
                    "printedName": "CoreImage.CIImage",
                    "usr": "c:objc(cs)CIImage"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "CGSize",
                "printedName": "CoreFoundation.CGSize",
                "usr": "c:@S@CGSize"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLPixelFormat",
                "printedName": "Metal.MTLPixelFormat",
                "hasDefaultArg": true,
                "usr": "c:@E@MTLPixelFormat"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC9ciTexture_4size11pixelFormatSo10MTLTexture_pSgSo7CIImageCSg_So6CGSizeVSo08MTLPixelH0VtF",
            "mangledName": "$s4Muio11MetalDeviceC9ciTexture_4size11pixelFormatSo10MTLTexture_pSgSo7CIImageCSg_So6CGSizeVSo08MTLPixelH0VtF",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "ciTextures",
            "printedName": "ciTextures(_:size:commandBuff:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLTexture)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLTexture",
                    "printedName": "any Metal.MTLTexture",
                    "usr": "c:objc(pl)MTLTexture"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "Array",
                "printedName": "[CoreImage.CIImage]",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CIImage",
                    "printedName": "CoreImage.CIImage",
                    "usr": "c:objc(cs)CIImage"
                  }
                ],
                "usr": "s:Sa"
              },
              {
                "kind": "TypeNominal",
                "name": "CGSize",
                "printedName": "CoreFoundation.CGSize",
                "usr": "c:@S@CGSize"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLCommandBuffer",
                "printedName": "any Metal.MTLCommandBuffer",
                "usr": "c:objc(pl)MTLCommandBuffer"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC10ciTextures_4size11commandBuffSo10MTLTexture_pSgSaySo7CIImageCG_So6CGSizeVSo16MTLCommandBuffer_ptF",
            "mangledName": "$s4Muio11MetalDeviceC10ciTextures_4size11commandBuffSo10MTLTexture_pSgSaySo7CIImageCG_So6CGSizeVSo16MTLCommandBuffer_ptF",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "scnTexture",
            "printedName": "scnTexture(_:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "MTLTexture",
                "printedName": "any Metal.MTLTexture",
                "usr": "c:objc(pl)MTLTexture"
              },
              {
                "kind": "TypeNominal",
                "name": "CGSize",
                "printedName": "CoreFoundation.CGSize",
                "usr": "c:@S@CGSize"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC10scnTextureySo10MTLTexture_pSo6CGSizeVFZ",
            "mangledName": "$s4Muio11MetalDeviceC10scnTextureySo10MTLTexture_pSo6CGSizeVFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "sceneToTexture",
            "printedName": "sceneToTexture(in:_:texture:time:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Void",
                "printedName": "()"
              },
              {
                "kind": "TypeNominal",
                "name": "SCNView",
                "printedName": "SceneKit.SCNView",
                "usr": "c:objc(cs)SCNView"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLCommandBuffer",
                "printedName": "any Metal.MTLCommandBuffer",
                "usr": "c:objc(pl)MTLCommandBuffer"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLTexture",
                "printedName": "any Metal.MTLTexture",
                "paramValueOwnership": "InOut",
                "usr": "c:objc(pl)MTLTexture"
              },
              {
                "kind": "TypeNominal",
                "name": "Double",
                "printedName": "Swift.Double",
                "usr": "s:Sd"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC14sceneToTexture2in_7texture4timeySo7SCNViewC_So16MTLCommandBuffer_pSo10MTLTexture_pzSdtFZ",
            "mangledName": "$s4Muio11MetalDeviceC14sceneToTexture2in_7texture4timeySo7SCNViewC_So16MTLCommandBuffer_pSo10MTLTexture_pzSdtFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "computeState",
            "printedName": "computeState(compStr:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "ImplicitlyUnwrappedOptional",
                "printedName": "(any Metal.MTLComputePipelineState)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLComputePipelineState",
                    "printedName": "any Metal.MTLComputePipelineState",
                    "usr": "c:objc(pl)MTLComputePipelineState"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "String",
                "printedName": "Swift.String",
                "usr": "s:SS"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC12computeState7compStrSo018MTLComputePipelineE0_pSgSS_tF",
            "mangledName": "$s4Muio11MetalDeviceC12computeState7compStrSo018MTLComputePipelineE0_pSgSS_tF",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "dstTexture",
            "printedName": "dstTexture(buffer:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "(any Metal.MTLTexture)?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "MTLTexture",
                    "printedName": "any Metal.MTLTexture",
                    "usr": "c:objc(pl)MTLTexture"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "ImplicitlyUnwrappedOptional",
                "printedName": "CoreVideo.CVBuffer?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CVBuffer",
                    "printedName": "CoreVideo.CVBuffer",
                    "usr": "c:@T@CVBufferRef"
                  }
                ],
                "usr": "s:Sq"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC10dstTexture6bufferSo10MTLTexture_pSgSo11CVBufferRefaSg_tF",
            "mangledName": "$s4Muio11MetalDeviceC10dstTexture6bufferSo10MTLTexture_pSgSo11CVBufferRefaSg_tF",
            "moduleName": "Muio",
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "allocateBufferPool",
            "printedName": "allocateBufferPool(with:outputRetainedBufferCountHint:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Tuple",
                "printedName": "(outputBufferPool: CoreVideo.CVPixelBufferPool?, outputColorSpace: CoreGraphics.CGColorSpace?, outputFormatDescription: CoreMedia.CMFormatDescription?)",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Optional",
                    "printedName": "CoreVideo.CVPixelBufferPool?",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "CVPixelBufferPool",
                        "printedName": "CoreVideo.CVPixelBufferPool",
                        "usr": "c:@T@CVPixelBufferPoolRef"
                      }
                    ],
                    "usr": "s:Sq"
                  },
                  {
                    "kind": "TypeNominal",
                    "name": "Optional",
                    "printedName": "CoreGraphics.CGColorSpace?",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "CGColorSpace",
                        "printedName": "CoreGraphics.CGColorSpace",
                        "usr": "c:@T@CGColorSpaceRef"
                      }
                    ],
                    "usr": "s:Sq"
                  },
                  {
                    "kind": "TypeNominal",
                    "name": "Optional",
                    "printedName": "CoreMedia.CMFormatDescription?",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "CMFormatDescription",
                        "printedName": "CoreMedia.CMFormatDescription",
                        "usr": "c:@T@CMFormatDescriptionRef"
                      }
                    ],
                    "usr": "s:Sq"
                  }
                ]
              },
              {
                "kind": "TypeNominal",
                "name": "CMFormatDescription",
                "printedName": "CoreMedia.CMFormatDescription",
                "usr": "c:@T@CMFormatDescriptionRef"
              },
              {
                "kind": "TypeNominal",
                "name": "Int",
                "printedName": "Swift.Int",
                "usr": "s:Si"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC18allocateBufferPool4with014outputRetainedE9CountHintSo07CVPixeleF3RefaSg0heF0_So012CGColorSpaceM0aSg0h5ColorO0So019CMFormatDescriptionM0aSg0h6FormatR0tAP_SitFZ",
            "mangledName": "$s4Muio11MetalDeviceC18allocateBufferPool4with014outputRetainedE9CountHintSo07CVPixeleF3RefaSg0heF0_So012CGColorSpaceM0aSg0h5ColorO0So019CMFormatDescriptionM0aSg0h6FormatR0tAP_SitFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "preallocateBuffers",
            "printedName": "preallocateBuffers(pool:allocationThreshold:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Void",
                "printedName": "()"
              },
              {
                "kind": "TypeNominal",
                "name": "CVPixelBufferPool",
                "printedName": "CoreVideo.CVPixelBufferPool",
                "usr": "c:@T@CVPixelBufferPoolRef"
              },
              {
                "kind": "TypeNominal",
                "name": "Int",
                "printedName": "Swift.Int",
                "usr": "s:Si"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC18preallocateBuffers4pool19allocationThresholdySo20CVPixelBufferPoolRefa_SitFZ",
            "mangledName": "$s4Muio11MetalDeviceC18preallocateBuffers4pool19allocationThresholdySo20CVPixelBufferPoolRefa_SitFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl",
              "RawDocComment"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "jpegDataFromCIImage",
            "printedName": "jpegDataFromCIImage(from:attachments:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "Foundation.Data?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Data",
                    "printedName": "Foundation.Data",
                    "usr": "s:10Foundation4DataV"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "CIImage",
                "printedName": "CoreImage.CIImage",
                "usr": "c:objc(cs)CIImage"
              },
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "CoreFoundation.CFDictionary?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CFDictionary",
                    "printedName": "CoreFoundation.CFDictionary",
                    "usr": "c:@T@CFDictionaryRef"
                  }
                ],
                "usr": "s:Sq"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC19jpegDataFromCIImage4from11attachments10Foundation0E0VSgSo0G0C_So15CFDictionaryRefaSgtFZ",
            "mangledName": "$s4Muio11MetalDeviceC19jpegDataFromCIImage4from11attachments10Foundation0E0VSgSo0G0C_So15CFDictionaryRefaSgtFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl",
              "RawDocComment"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "jpegDataFromCGImage",
            "printedName": "jpegDataFromCGImage(from:attachments:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "Foundation.Data?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Data",
                    "printedName": "Foundation.Data",
                    "usr": "s:10Foundation4DataV"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "CGImage",
                "printedName": "CoreGraphics.CGImage",
                "usr": "c:@T@CGImageRef"
              },
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "CoreFoundation.CFDictionary?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CFDictionary",
                    "printedName": "CoreFoundation.CFDictionary",
                    "usr": "c:@T@CFDictionaryRef"
                  }
                ],
                "usr": "s:Sq"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC19jpegDataFromCGImage4from11attachments10Foundation0E0VSgSo0G3Refa_So012CFDictionaryK0aSgtFZ",
            "mangledName": "$s4Muio11MetalDeviceC19jpegDataFromCGImage4from11attachments10Foundation0E0VSgSo0G3Refa_So012CFDictionaryK0aSgtFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl",
              "RawDocComment"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "saveCIImageToCameraRoll",
            "printedName": "saveCIImageToCameraRoll(image:_:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Void",
                "printedName": "()"
              },
              {
                "kind": "TypeNominal",
                "name": "CIImage",
                "printedName": "CoreImage.CIImage",
                "usr": "c:objc(cs)CIImage"
              },
              {
                "kind": "TypeFunc",
                "name": "Function",
                "printedName": "() -> ()",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Void",
                    "printedName": "()"
                  },
                  {
                    "kind": "TypeNominal",
                    "name": "Void",
                    "printedName": "()"
                  }
                ]
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC23saveCIImageToCameraRoll5image_ySo0E0C_yyctFZ",
            "mangledName": "$s4Muio11MetalDeviceC23saveCIImageToCameraRoll5image_ySo0E0C_yyctFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "jpegData",
            "printedName": "jpegData(withPixelBuffer:attachments:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "Foundation.Data?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Data",
                    "printedName": "Foundation.Data",
                    "usr": "s:10Foundation4DataV"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "CVBuffer",
                "printedName": "CoreVideo.CVBuffer",
                "usr": "c:@T@CVBufferRef"
              },
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "CoreFoundation.CFDictionary?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CFDictionary",
                    "printedName": "CoreFoundation.CFDictionary",
                    "usr": "c:@T@CFDictionaryRef"
                  }
                ],
                "usr": "s:Sq"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC8jpegData15withPixelBuffer11attachments10Foundation0E0VSgSo11CVBufferRefa_So012CFDictionaryL0aSgtFZ",
            "mangledName": "$s4Muio11MetalDeviceC8jpegData15withPixelBuffer11attachments10Foundation0E0VSgSo11CVBufferRefa_So012CFDictionaryL0aSgtFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "funcSelfKind": "NonMutating"
          },
          {
            "kind": "Function",
            "name": "cgImage",
            "printedName": "cgImage(from:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Optional",
                "printedName": "CoreGraphics.CGImage?",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "CGImage",
                    "printedName": "CoreGraphics.CGImage",
                    "usr": "c:@T@CGImageRef"
                  }
                ],
                "usr": "s:Sq"
              },
              {
                "kind": "TypeNominal",
                "name": "MTLTexture",
                "printedName": "any Metal.MTLTexture",
                "usr": "c:objc(pl)MTLTexture"
              }
            ],
            "declKind": "Func",
            "usr": "s:4Muio11MetalDeviceC7cgImage4fromSo10CGImageRefaSgSo10MTLTexture_p_tKFZ",
            "mangledName": "$s4Muio11MetalDeviceC7cgImage4fromSo10CGImageRefaSgSo10MTLTexture_p_tKFZ",
            "moduleName": "Muio",
            "static": true,
            "declAttributes": [
              "Final",
              "AccessControl"
            ],
            "throwing": true,
            "funcSelfKind": "NonMutating"
          }
        ],
        "declKind": "Class",
        "usr": "s:4Muio11MetalDeviceC",
        "mangledName": "$s4Muio11MetalDeviceC",
        "moduleName": "Muio",
        "declAttributes": [
          "AccessControl"
        ],
        "hasMissingDesignatedInitializers": true
      },
      {
        "kind": "TypeDecl",
        "name": "SIMD2",
        "printedName": "SIMD2",
        "children": [
          {
            "kind": "Function",
            "name": "convertCoord",
            "printedName": "convertCoord()",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "SIMD2",
                "printedName": "Swift.SIMD2<Swift.Float>",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Float",
                    "printedName": "Swift.Float",
                    "usr": "s:Sf"
                  }
                ],
                "usr": "s:s5SIMD2V"
              }
            ],
            "declKind": "Func",
            "usr": "s:s5SIMD2V4MuioSfRszrlE12convertCoordABySfGyF",
            "mangledName": "$ss5SIMD2V4MuioSfRszrlE12convertCoordABySfGyF",
            "moduleName": "Muio",
            "genericSig": "<τ_0_0 where τ_0_0 == Swift.Float>",
            "sugared_genericSig": "<Scalar where Scalar == Swift.Float>",
            "declAttributes": [
              "AccessControl"
            ],
            "isFromExtension": true,
            "funcSelfKind": "NonMutating"
          }
        ],
        "declKind": "Struct",
        "usr": "s:s5SIMD2V",
        "mangledName": "$ss5SIMD2V",
        "moduleName": "Swift",
        "genericSig": "<τ_0_0 where τ_0_0 : Swift.SIMDScalar>",
        "sugared_genericSig": "<Scalar where Scalar : Swift.SIMDScalar>",
        "declAttributes": [
          "Frozen"
        ],
        "isExternal": true,
        "conformances": [
          {
            "kind": "Conformance",
            "name": "SIMD",
            "printedName": "SIMD",
            "children": [
              {
                "kind": "TypeWitness",
                "name": "MaskStorage",
                "printedName": "MaskStorage",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "SIMD2",
                    "printedName": "Swift.SIMD2<τ_0_0.SIMDMaskScalar>",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "DependentMember",
                        "printedName": "τ_0_0.SIMDMaskScalar"
                      }
                    ],
                    "usr": "s:s5SIMD2V"
                  }
                ]
              }
            ],
            "usr": "s:s4SIMDP",
            "mangledName": "$ss4SIMDP"
          },
          {
            "kind": "Conformance",
            "name": "CustomStringConvertible",
            "printedName": "CustomStringConvertible",
            "usr": "s:s23CustomStringConvertibleP",
            "mangledName": "$ss23CustomStringConvertibleP"
          },
          {
            "kind": "Conformance",
            "name": "Decodable",
            "printedName": "Decodable",
            "usr": "s:Se",
            "mangledName": "$sSe"
          },
          {
            "kind": "Conformance",
            "name": "Encodable",
            "printedName": "Encodable",
            "usr": "s:SE",
            "mangledName": "$sSE"
          },
          {
            "kind": "Conformance",
            "name": "ExpressibleByArrayLiteral",
            "printedName": "ExpressibleByArrayLiteral",
            "children": [
              {
                "kind": "TypeWitness",
                "name": "ArrayLiteralElement",
                "printedName": "ArrayLiteralElement",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "GenericTypeParam",
                    "printedName": "τ_0_0"
                  }
                ]
              }
            ],
            "usr": "s:s25ExpressibleByArrayLiteralP",
            "mangledName": "$ss25ExpressibleByArrayLiteralP"
          },
          {
            "kind": "Conformance",
            "name": "Hashable",
            "printedName": "Hashable",
            "usr": "s:SH",
            "mangledName": "$sSH"
          },
          {
            "kind": "Conformance",
            "name": "SIMDStorage",
            "printedName": "SIMDStorage",
            "children": [
              {
                "kind": "TypeWitness",
                "name": "Scalar",
                "printedName": "Scalar",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "GenericTypeParam",
                    "printedName": "τ_0_0"
                  }
                ]
              }
            ],
            "usr": "s:s11SIMDStorageP",
            "mangledName": "$ss11SIMDStorageP"
          },
          {
            "kind": "Conformance",
            "name": "Equatable",
            "printedName": "Equatable",
            "usr": "s:SQ",
            "mangledName": "$sSQ"
          },
          {
            "kind": "Conformance",
            "name": "CustomDebugStringConvertible",
            "printedName": "CustomDebugStringConvertible",
            "usr": "s:s28CustomDebugStringConvertibleP",
            "mangledName": "$ss28CustomDebugStringConvertibleP"
          },
          {
            "kind": "Conformance",
            "name": "Sendable",
            "printedName": "Sendable",
            "usr": "s:s8SendableP",
            "mangledName": "$ss8SendableP"
          }
        ]
      },
      {
        "kind": "TypeDecl",
        "name": "MTLRenderCommandEncoder",
        "printedName": "MTLRenderCommandEncoder",
        "children": [
          {
            "kind": "Function",
            "name": "setFragmentTextures",
            "printedName": "setFragmentTextures(_:startingAt:)",
            "children": [
              {
                "kind": "TypeNominal",
                "name": "Void",
                "printedName": "()"
              },
              {
                "kind": "TypeNominal",
                "name": "Array",
                "printedName": "[(any Metal.MTLTexture)?]",
                "children": [
                  {
                    "kind": "TypeNominal",
                    "name": "Optional",
                    "printedName": "(any Metal.MTLTexture)?",
                    "children": [
                      {
                        "kind": "TypeNominal",
                        "name": "MTLTexture",
                        "printedName": "any Metal.MTLTexture",
                        "usr": "c:objc(pl)MTLTexture"
                      }
                    ],
                    "usr": "s:Sq"
                  }
                ],
                "usr": "s:Sa"
              },
              {
                "kind": "TypeNominal",
                "name": "Int",
                "printedName": "Swift.Int",
                "hasDefaultArg": true,
                "usr": "s:Si"
              }
            ],
            "declKind": "Func",
            "usr": "s:So23MTLRenderCommandEncoderP4MuioE19setFragmentTextures_10startingAtySaySo10MTLTexture_pSgG_SitF",
            "mangledName": "$sSo23MTLRenderCommandEncoderP4MuioE19setFragmentTextures_10startingAtySaySo10MTLTexture_pSgG_SitF",
            "moduleName": "Muio",
            "genericSig": "<τ_0_0 where τ_0_0 : Metal.MTLRenderCommandEncoder>",
            "sugared_genericSig": "<Self where Self : Metal.MTLRenderCommandEncoder>",
            "isFromExtension": true,
            "funcSelfKind": "NonMutating"
          }
        ],
        "declKind": "Protocol",
        "usr": "c:objc(pl)MTLRenderCommandEncoder",
        "moduleName": "Metal",
        "genericSig": "<τ_0_0 : Metal.MTLCommandEncoder>",
        "sugared_genericSig": "<Self : Metal.MTLCommandEncoder>",
        "intro_iOS": "8.0",
        "objc_name": "MTLRenderCommandEncoder",
        "declAttributes": [
          "Available",
          "ObjC",
          "Dynamic"
        ],
        "isExternal": true
      }
    ],
    "json_format_version": 8
  },
  "ConstValues": [
    {
      "filePath": "\/Users\/demiannezhdanov\/Projects\/myFRAMEWORKS\/FRamework\/Muio\/Muio\/Device\/MetalDevice.swift",
      "kind": "StringLiteral",
      "offset": 3400,
      "length": 14,
      "value": "\"vertexShader\""
    },
    {
      "filePath": "\/Users\/demiannezhdanov\/Projects\/myFRAMEWORKS\/FRamework\/Muio\/Muio\/Device\/MetalDevice.swift",
      "kind": "StringLiteral",
      "offset": 3779,
      "length": 2,
      "value": "\"\""
    },
    {
      "filePath": "\/Users\/demiannezhdanov\/Projects\/myFRAMEWORKS\/FRamework\/Muio\/Muio\/Device\/MetalDevice.swift",
      "kind": "Array",
      "offset": 7662,
      "length": 34,
      "value": "[0, 1, 2, 2, 3, 0]"
    },
    {
      "filePath": "\/Users\/demiannezhdanov\/Projects\/myFRAMEWORKS\/FRamework\/Muio\/Muio\/Device\/MetalDevice.swift",
      "kind": "StringLiteral",
      "offset": 7777,
      "length": 14,
      "value": "\"vertexShader\""
    },
    {
      "filePath": "\/Users\/demiannezhdanov\/Projects\/myFRAMEWORKS\/FRamework\/Muio\/Muio\/Device\/MetalDevice.swift",
      "kind": "IntegerLiteral",
      "offset": 31972,
      "length": 1,
      "value": "0"
    },
    {
      "filePath": "\/Users\/demiannezhdanov\/Projects\/myFRAMEWORKS\/FRamework\/Muio\/Muio\/Device\/MetalDevice.swift",
      "kind": "StringLiteral",
      "offset": 32103,
      "length": 65497,
      "value": "\"\/\/\n\/\/  MTLVid.metal\n\/\/  MTLVid\n\/\/\n\/\/  Created by Demian Nezhdanov on 10\/10\/2024.\n\/\/\n\n#include <metal_stdlib>\nusing namespace metal;\n\nstruct VertexIn {\n    float2 position [[attribute(0)]];\n    float2 textureCoorinates [[attribute(1)]];\n};\n\nstruct VertexOut {\n    float4 position [[position]];\n    float2 textureCoorinates;\n};\n\nstruct EffectUniforms{\n    int type;\n    float strength;\n};\nstruct GrainUniforms{\n    int grainType;\n    float grainStrength;\n    int grainBlendMode;\n};\nstruct OverlayUniforms{\n\n    float overlayStrength;\n    int overlayBlendMode;\n};\n#define MAX_EFFECT_UNIFORMS 10\ntypedef struct {\n    \n    float u_time ;\n    float lutIntesity;\n    float effectValue;\n    simd_float2 res;\n    int isMirroredH;\n    int isMirroredV;\n    \n    int doubleExposure;\n    int showPreview;\n    \n\/\/    struct EffectUniforms effects[2];\n    int filtersCount;\n    int overlaysCount;\n    int grainBuffersCount;\n    float blurValue;\n    \n}MetalUniform;\n\n\nconstexpr metal::sampler sam(metal::filter::linear);\nconstexpr metal::sampler samLut(metal::filter::nearest);\n\n\n\n\nfloat3 exposure(float intensity, float3 color)\n{\n    const float gamma = 2.2;\n    \n    \/\/ exposure tone mapping\n    float3 mapped = float3(1.0) - exp(-color * intensity);\n    \/\/ gamma correction\n    mapped = pow(mapped, float3(1.0 \/ gamma));\n  \n    return mapped;\n}\n\n\/\/MARK: ADJUSTMENT TOOLS\nfloat3 shadows(float3 source,  float shadows,float highlights){\n\n\n    float3 luminanceWeighting = float3(0.3, 0.3, 0.3);\n    \n    \n   float luminance = dot(source.rgb, luminanceWeighting);\n    \n    \/\/(shadows+1.0) changed to just shadows:\n    float shadow = clamp((pow(luminance, 1.0\/shadows) + (-0.76)*pow(luminance, 2.0\/shadows)) - luminance, 0.0, 1.0);\n    float highlight = clamp((1.0 - (pow(1.0-luminance, 1.0\/(2.0-highlights)) + (-0.8)*pow(1.0-luminance, 2.0\/(2.0-highlights)))) - luminance, -1.0, 0.0);\n    float3 result = float3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((source.rgb - float3(0.0, 0.0, 0.0))\/(luminance - 0.0));\n    \n    \/\/ blend toward white if highlights is more than 1\n    float contrastedLuminance = ((luminance - 0.5) * 1.5) + 0.5;\n    float whiteInterp = contrastedLuminance*contrastedLuminance*contrastedLuminance;\n    float whiteTarget = clamp(highlights, 1.0, 2.0) - 1.0;\n    result = mix(result, float3(1.0), whiteInterp*whiteTarget);\n    \n    \/\/ blend toward black if shadows is less than 1\n    float invContrastedLuminance = 1.0 - contrastedLuminance;\n    float blackInterp = invContrastedLuminance*invContrastedLuminance*invContrastedLuminance;\n    float blackTarget = 1.0 - clamp(shadows, 0.0, 1.0);\n    result = mix(result, float3(0.0), blackInterp*blackTarget);\n    \n    return result;\n}\n\n\nfloat4x4 brightnessMatrix( float brightness )\n{\n    return float4x4( 1, 0, 0, 0,\n                 0, 1, 0, 0,\n                 0, 0, 1, 0,\n                 brightness, brightness, brightness, 1 );\n}\n\nfloat4x4 contrastMatrix( float contrast )\n{\n    float t = ( 1.0 - contrast ) \/ 2.0;\n    \n    return float4x4( contrast, 0, 0, 0,\n                 0, contrast, 0, 0,\n                 0, 0, contrast, 0,\n                 t, t, t, 1 );\n\n}\nfloat easyIn(float val){\n    return pow(val, 2.0);\n}\n\nfloat easyOut(float val){\n    return 1.0 - pow(1.0 - val, 2.0);\n}\n\nfloat easyInEasyOut(float val){\n    return (val < 0.5) ? easyIn(val * 2.0) \/ 2.0 : easyOut(val * 2.0 - 1.0) \/ 2.0 + 0.5;\n}\nfloat3 saturation(float3 rgb, float adj)\n{\n    const float3 W = float3(0.2125, 0.7154, 0.0721);\n    float3 intensity = float3(dot(rgb, W));\n    return mix(intensity, rgb, adj);\n}\nhalf3 blur(texture2d<half> tex, float2 uv, float r){\n    constexpr metal::sampler samNMain(metal::filter::linear,address::clamp_to_edge);\n    half3 blur = half3(0.0);\n     float2 res = float2(tex.get_width(),tex.get_height());\n         float sum = 0.0;\n        \/\/float r = rad;\n         for(float u = -r; u<=r; u+=1.){\n             for(float v = -r; v<=r; v+=1.){\n \n                 float weight = r*10. - sqrt(u * u + v * v);\n                \/\/ uv + (float2(u, v)\/res)\n                 blur += weight * tex.sample(samNMain,uv + (float2(u, v)\/res)).rgb;\n                 sum += weight;\n             }\n         }\n         blur \/= sum;\n     \n    return blur;\n}\n\n\n\nhalf3 rgb2hsv(half3 c)\n{\n    half4 k = half4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    half4 p = mix(half4(c.bg, k.wz), half4(c.gb, k.xy), step(c.b, c.g));\n    half4 q = mix(half4(p.xyw, c.r), half4(c.r, p.yzx), step(p.x, c.r));\n\n    half d = q.x - min(q.w, q.y);\n    half e = 1.0e-10;\n    return half3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nhalf3 hsv2rgb(half3 c)\n{\n    half4 k = half4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    half3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n    return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nfloat3 palet(float v ) {\n    return (float3(0.26) + tan(1.09)*sin(1.09)*0.26 * cos(3.18318 * (v + float3(0.0,0.333,0.567)))).brg;\n}\n\n\n\n\n\n\nfloat saturateF(float x)\n{\n    return clamp(x, 0.,1.);\n}\nfloat3 highlight(float3 color, float intensity)\n{\n    const float a = 1.357697966704323E-01;\n    const float b = 1.006045552016985E+00;\n    const float c = 4.674339906510876E-01;\n    const float d = 8.029414702292208E-01;\n    const float e = 1.127806558508491E-01;\n    \n    float maxx = max(color.r, max(color.g, color.b));\n    float minx = min(color.r, min(color.g, color.b));\n    float lum = 0.5 * (maxx + minx);\n    float x1 = abs(intensity);\n    float x2 = lum;\n    float lum_new =  lum < 0.5 ? lum : lum + a * sign(intensity) * exp(-0.5 * (((x1-b)\/c)*((x1-b)\/c) + ((x2-d)\/e)*((x2-d)\/e)));\n    return color * lum_new \/ lum;\n}\n\/\/MARK: ADJUSTMENT TOOLS\n\n\n\n\n\n\/\/MARK: BLEND MODES\nhalf3 screen(half3 baseColor, half3 blendColor) {\n    half3 resultColor;\n    resultColor.rgb = 1.0 - ((1.0 - baseColor.rgb) * (1.0 - blendColor.rgb));\n    \n    return resultColor;\n}\n\nhalf3 screenVo( half3 s, half3 d )\n{\n    return s + d - s * d;\n}\nhalf3 darken( half3 s, half3 d )\n{\n    return min(s,d);\n}\n\nhalf3 multiply( half3 s, half3 d )\n{\n    return s*d;\n}\n\nhalf3 colorBurn( half3 s, half3 d )\n{\n    return 1.0 - (1.0 - d) \/ s;\n}\n\nhalf3 linearBurn( half3 s, half3 d )\n{\n    return s + d - 1.0;\n}\n\nhalf3 darkerColor( half3 s, half3 d )\n{\n    return (s.x + s.y + s.z < d.x + d.y + d.z) ? s : d;\n}\n\nhalf3 lighten( half3 s, half3 d )\n{\n    return max(s,d);\n}\n\nhalf3 colorDodge( half3 s, half3 d )\n{\n    return d \/ abs(1.0 - s);\n}\nfloat blendColorDodge(float base, float blend) {\n    return (blend==1.0)?blend:min(base\/(1.0-blend),1.0);\n}\n\nhalf3 colorDodge_n(half3 blend,half3 base) {\n    return half3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nhalf3 blendColorDodge(half3 base, half3 blend, float opacity) {\n    return (colorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nhalf3 linearDodge( half3 s, half3 d )\n{\n    return s + d;\n}\n\nhalf3 lighterColor( half3 s, half3 d )\n{\n    return (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d;\n}\n\nfloat overlay( float s, float d )\n{\n    return (d < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\n\/\/half3 overlay( half3 s, half3 d )\n\/\/{\n\/\/    half3 c;\n\/\/    c.x = overlay(s.x,d.x);\n\/\/    c.y = overlay(s.y,d.y);\n\/\/    c.z = overlay(s.z,d.z);\n\/\/    return c;\n\/\/}\n\/\/half3 overlay (half3 target, half3 blend){\n\/\/    half3 temp;\n\/\/    temp.x = (target.x > 0.5) ? (1.0-(1.0-2.0*(target.x-0.5))*(1.0-blend.x)) : (2.0*target.x)*blend.x;\n\/\/    temp.y = (target.y > 0.5) ? (1.0-(1.0-2.0*(target.y-0.5))*(1.0-blend.y)) : (2.0*target.y)*blend.y;\n\/\/    temp.z = (target.z > 0.5) ? (1.0-(1.0-2.0*(target.z-0.5))*(1.0-blend.z)) : (2.0*target.z)*blend.z;\n\/\/    return temp;\n\/\/}\n\nhalf3 overlay( half3 overlayColor,half3 baseColor) {\n    half3 resultColor;\n    resultColor.rgb = mix(\n        2.0f * baseColor.rgb * overlayColor.rgb,\n        1.0f - 2.0f * (1.0f - baseColor.rgb) * (1.0f - overlayColor.rgb),\n        step(0.5f, baseColor.rgb)\n    );\n\/\/    resultColor.a = baseColor.a; \/\/ keep the original alpha\n    return resultColor;\n}\n\nfloat softLight( float s, float d )\n{\n    return (s < 0.5) ? d - (1.0 - 2.0 * s) * d * (1.0 - d)\n        : (d < 0.25) ? d + (2.0 * s - 1.0) * d * ((16.0 * d - 12.0) * d + 3.0)\n                     : d + (2.0 * s - 1.0) * (sqrt(d) - d);\n}\n\nhalf4 softLight( half4 s, half4 d )\n{\n    half4 c;\n    c.x = softLight(s.x,d.x);\n    c.y = softLight(s.y,d.y);\n    c.z = softLight(s.z,d.z);\n    c.a = softLight(s.a,d.a);\n    return c;\n}\n\nfloat hardLight( float s, float d )\n{\n    return (s < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nhalf3 hardLight( half3 s, half3 d )\n{\n    half3 c;\n    c.x = hardLight(s.x,d.x);\n    c.y = hardLight(s.y,d.y);\n    c.z = hardLight(s.z,d.z);\n    return c;\n}\n\nfloat vividLight( float s, float d )\n{\n    return (s < 0.5) ? 1.0 - (1.0 - d) \/ (2.0 * s) : d \/ (2.0 * (1.0 - s));\n}\n\nhalf3 vividLight( half3 s, half3 d )\n{\n    half3 c;\n    c.x = vividLight(s.x,d.x);\n    c.y = vividLight(s.y,d.y);\n    c.z = vividLight(s.z,d.z);\n    return c;\n}\n\nhalf3 linearLight( half3 s, half3 d )\n{\n    return 2.0 * s + d - 1.0;\n}\n\nfloat pinLight( float s, float d )\n{\n    return (2.0 * s - 1.0 > d) ? 2.0 * s - 1.0 : (s < 0.5 * d) ? 2.0 * s : d;\n}\n\nhalf3 pinLight( half3 s, half3 d )\n{\n    half3 c;\n    c.x = pinLight(s.x,d.x);\n    c.y = pinLight(s.y,d.y);\n    c.z = pinLight(s.z,d.z);\n    return c;\n}\n\nhalf3 hardMix( half3 s, half3 d )\n{\n    return floor(s + d);\n}\n\nhalf3 difference( half3 s, half3 d )\n{\n    return abs(d - s);\n}\n\nhalf3 exclusion( half3 s, half3 d )\n{\n    return s + d - 2.0 * s * d;\n}\n\nhalf3 subtract( half3 s, half3 d )\n{\n    return s - d;\n}\n\nhalf3 divideBlendMode( half3 s, half3 d )\n{\n    return s \/ d;\n}\n\n\nhalf3 hue( half3 s, half3 d )\n{\n    d = rgb2hsv(d);\n    d.x = rgb2hsv(s).x;\n    return hsv2rgb(d);\n}\n\nhalf3 color( half3 s, half3 d )\n{\n    s = rgb2hsv(s);\n    s.z = rgb2hsv(d).z;\n    return hsv2rgb(s);\n}\n\nhalf3 saturation( half3 s, half3 d )\n{\n    d = rgb2hsv(d);\n    d.y = rgb2hsv(s).y;\n    return hsv2rgb(d);\n}\n\nhalf3 luminosity( half3 s, half3 d )\n{\n    float dLum = dot(d, half3(0.3, 0.59, 0.11));\n    float sLum = dot(s, half3(0.3, 0.59, 0.11));\n    float lum = sLum - dLum;\n    half3 c = d + lum;\n    float minC = min(min(c.x, c.y), c.z);\n    float maxC = max(max(c.x, c.y), c.z);\n    if(minC < 0.0) return sLum + ((c - sLum) * sLum) \/ (sLum - minC);\n    else if(maxC > 1.0) return sLum + ((c - sLum) * (1.0 - sLum)) \/ (maxC - sLum);\n    else return c;\n}\n\n\n\n\n\nhalf3 blend( half3 s, half3 d, int mode )\n{\n    if(mode==0)    return darken(s,d);\n    if(mode==1)    return multiply(s,d);\n    if(mode==2)    return colorBurn(s,d);\n    if(mode==3)    return linearBurn(s,d);\n    if(mode==4)    return darkerColor(s,d);\n    if(mode==5)    return lighten(s,d);\n    if(mode==6)    return screen(s,d);\n    if(mode==7)    return colorDodge(s,d);\n    if(mode==8)    return linearDodge(s,d);\n    if(mode==9)    return lighterColor(s,d);\n    if(mode==10)    return overlay(s,d);\n\/\/    if(mode==11)    return softLight(s,d);\n    if(mode==12)    return hardLight(s,d);\n    if(mode==13)    return vividLight(s,d);\n    if(mode==14)    return linearLight(s,d);\n    if(mode==15)    return pinLight(s,d);\n    if(mode==16)    return hardMix(s,d);\n    if(mode==17)    return difference(s,d);\n    if(mode==18)    return exclusion(s,d);\n    if(mode==19)    return subtract(s,d);\n    if(mode==20)    return divideBlendMode(s,d);\n    if(mode==21)    return hue(s,d);\n    if(mode==22)    return color(s,d);\n    if(mode==23)    return saturation(s,d);\n    if(mode==24)    return luminosity(s,d);\n    \n    return half3(0.0);\n}\n\/\/https:\/\/www.shadertoy.com\/view\/XdS3RW\n\n\n\n\n\/\/MARK: BLEND MODES\n\n\n\n\n\n\n\n\n\n\n\n\n\/\/MARK: GEOMETRY\nfloat point(float2 pos, float2 uv, float2 res){\n    uv -= pos;\n    uv.y \/= res.x\/res.y;\n  \n    float d = length(uv);\n    d = smoothstep(0.25, 0.0, d)\/34.;\n    return d;\n}\n\/\/MARK: GEOMETRY\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloat2 rotateUV(float2 uv, float rotation)\n{\n    return float2(\n        cos(rotation) * uv.x + sin(rotation) * uv.y,\n        cos(rotation) * uv.y - sin(rotation) * uv.x\n    );\n}\nfloat dist(half3 a, half3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }\n\n\nfloat mod(float x, float y) {\n    return x - y * floor(x \/ y);\n}\nfloat2 mod(float2 x, float y){\n    return x - y * floor(x\/y);\n}\nhalf3 mod(half3 x, half3 y){\n    return x - y * floor(x\/y);\n}\n\n\n\/\/LUT\n\n\n\n\/\/half3 lookupT(half3 texColor,texture2d<float> lut, float2 uv, float intensity){\n\/\/     half3 color = half3(0);\n\/\/\/\/     constexpr sampler sam(filter::linear);\n\/\/\/\/     float2 uvLut = uv * 0.5 + 0.5;33\n\/\/    \/\/ half3 texColor = tex.sample(sam, uv).rgb;\n\/\/\/\/     float3 lutColor = lut.sample(sam, uvLut).rgb;\n\/\/     float yColor = texColor.b * 63.0;\n\/\/     float2 quad1 = float2(0);\n\/\/     quad1.y = floor(floor(yColor) \/ 8.0);\n\/\/     quad1.x = floor(yColor) - (quad1.y * 8.0);\n\/\/     float2 quad2 = float2(0);\n\/\/     quad2.y = floor(ceil(yColor) \/ 8.0);\n\/\/     quad2.x = ceil(yColor) - (quad2.y * 8.0);\n\/\/     float2 texPos1 = float2(0);\n\/\/    texPos1.x = (quad1.x * 0.125) + 0.5\/512.0 + ((0.125 - 1.0\/512.0) * texColor.r);\n\/\/    texPos1.y = (quad1.y * 0.125) + 0.5\/512.0 + ((0.125 - 1.0\/512.0) * texColor.g);\n\/\/     float2 texPos2 = float2(0);\n\/\/    texPos2.x = (quad2.x * 0.125) + 0.5\/512.0 + ((0.125 - 1.0\/512.0) * texColor.r);\n\/\/    texPos2.y = (quad2.y * 0.125) + 0.5\/512.0 + ((0.125 - 1.0\/512.0) * texColor.g);\n\/\/     float3 newColor1 = float3(0);\n\/\/     float3 newColor2 = float3(0);\n\/\/     newColor1 = lut.sample(samLut, texPos1).rgb*2.0;\n\/\/     newColor2 = lut.sample(samLut, texPos2).rgb*2.0;\n\/\/\n\/\/\n\/\/     float3 newColor = mix(newColor1, newColor2, fract(yColor));\n\/\/\/\/\n\/\/\/\/    newColor = exposure(0.2, newColor);\n\/\/\/\/        color = ( contrastMatrix( 1 + 0.2) * float4(color, 1.0)).rgb;\n\/\/    \/\/    color = shadows(float4(color,1.0),   1.1,1.);\n\/\/    \/\/        color = ( contrastMatrix( 1 + 0.16) * float4(color, 1.0)).rgb;\n\/\/     color = mix(texColor, newColor, intensity);\n\/\/\/\/    color = ( contrastMatrix( 1 + 0.1) * float4(color, 1.0)).rgb;\n\/\/\/\/    color = exposure(0.05, color);\n\/\/\n\/\/\n\/\/\n\/\/\n\/\/\n\/\/    return color;\n\/\/}\n\nhalf4 lutMix(half4 textureColor, float2 textureCoordinate, texture2d<half> lookupTexture, float intensity) {\n\/\/    float4 textureColor = inputImageTexture.sample(sam,textureCoordinate);\n    float blueColor = textureColor.b * 63.0;\n\n    float2 quad1;\n    quad1.y = floor(floor(blueColor) \/ 8.0);\n    quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\n    float2 quad2;\n    quad2.y = floor(ceil(blueColor) \/ 8.0);\n    quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\n    float2 texPos1;\n    texPos1.x = (quad1.x * 0.125) + 0.5\/512.0 + ((0.125 - 1.0\/512.0) * textureColor.r);\n    texPos1.y = (quad1.y * 0.125) + 0.5\/512.0 + ((0.125 - 1.0\/512.0) * textureColor.g);\n\n    float2 texPos2;\n    texPos2.x = (quad2.x * 0.125) + 0.5\/512.0 + ((0.125 - 1.0\/512.0) * textureColor.r);\n    texPos2.y = (quad2.y * 0.125) + 0.5\/512.0 + ((0.125 - 1.0\/512.0) * textureColor.g);\n\n    half4 newColor1 = lookupTexture.sample(sam,texPos1);\n    half4 newColor2 = lookupTexture.sample(sam,texPos2);\n    half4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\n    return mix(textureColor, half4(newColor.rgb, textureColor.w), intensity);\n}\n\n\n\nfloat3 lutMixx(texture2d<float> inputImageTexture, float2 textureCoordinate, texture2d<float> lookupTexture, float intensity) {\n     float2 tiles    = float2(8.0);\n     float2 tileSize = float2(64.0);\n     float4 texel = inputImageTexture.sample(sam, textureCoordinate);\n     float index = texel.b * (tiles.x * tiles.y - 1.0);\n     float index_min = min(62.0, floor(index));\n     float index_max = index_min + 1.0;\n\n     float2 tileIndex_min;\n     tileIndex_min.y = floor(index_min \/ tiles.x);\n     tileIndex_min.x = floor(index_min - tileIndex_min.y * tiles.x);\n     float2 tileIndex_max;\n     tileIndex_max.y = floor(index_max \/ tiles.x);\n     tileIndex_max.x = floor(index_max - tileIndex_max.y * tiles.x);\n\n     float2 tileUV = mix(0.5\/tileSize, (tileSize-0.5)\/tileSize, texel.rg);\n            \n     float2 tableUV_1 = tileIndex_min \/ tiles + tileUV \/ tiles;\n     float2 tableUV_2 = tileIndex_max \/ tiles + tileUV \/ tiles;\n            \n     float3 lookUpColor_1 = lookupTexture.sample(samLut, tableUV_1).rgb;\n     float3 lookUpColor_2 = lookupTexture.sample(samLut, tableUV_2).rgb;\n     float3 lookUpColor   = mix(lookUpColor_1, lookUpColor_2, index-index_min);\n\/\/    lookUpColor = ( contrastMatrix(0.9) * float4(lookUpColor, 1.0)).rgb;\n    return lookUpColor;\n}\n\n\/\/MARK: - 亮度\n\n\n\nfloat2 computeUV( float2 uv, float k ){\n    \n    float2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n    float f = 0.;\n    \n\/\/    if( kcube == 0.0){\n\/\/        f = 1. + r2 * k;\n\/\/    }else{\n        f = 1. + r2 * ( k +  sqrt( r2 ) );\n\/\/    }\n    \n    float2 nUv = f * t + .5;\n    \/\/nUv.y = 1. - nUv.y;\n \n    return nUv;\n    \n}\n\nfloat vingette(float2 uv,float scale,float smooth){\n    \n    uv -= 0.5;\n    \n    \n    \n\/\/        uv.x *= res.x\/res.y;\n    \n\/\/        uv.y *= res.y\/res.x;\n    \n    float d = length(uv);\n    d = smoothstep(scale + smooth,scale,d);\n    \n    \n    return  d;\n}\nfloat vingette(float2 uv, float2 res,float scale,float smooth){\n    \n    uv -= 0.5;\n    float aspect = res.x\/res.y;\n    \n    if(aspect < 1.0){\n        uv.x *= res.x\/res.y;\n    }else{\n        uv.y *= res.y\/res.x;\n    }\n    float d = length(uv);\n    d = smoothstep(scale + smooth,scale,d);\n    \n    \n    return  d;\n}\n\n\nfloat2x2 rotate2d(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return float2x2(c, -s, s, c);\n}\n\nfloat3 radialBlur(texture2d<float> tex, float2 uv, float power,int samples) {\n\n    \n    \n    float3 fragColor = float3(0.0);\n    for (int i = 0; i < samples; i ++)\n    {\n        uv -= 0.5;\n        uv *= rotate2d( power * float(i) );\n        uv += 0.5;\n        \n        fragColor += pow(tex.sample(sam,uv).rgb, float3(2.2));\n    }\n    \n    fragColor \/= float(samples);\n    fragColor = pow(fragColor, float3(1.\/2.2));\n    return fragColor;;\n}\nfloat3 smoothskin(texture2d<float> tex, float2 uv, float r  , float steps){\n     const float Y = 78.0;\n     float2 res = float2(tex.get_width(),tex.get_height());\n        float2 offset = float(1.0) \/ res.xy;\n        \n      \n        \n       \n    \/\/ rgb Separate calculation\n    float3 center_c = tex.sample(sam, uv).rgb;\n    float3 sum_c = float3(0.0);\n    for(int i = 0; i < 3; i++){\n         float sum_i = 0.0;\n        float norm = 0.0;\n        for(float x = -r; x <= r; x+=steps){\n            \n                for(float y = -r; y <= r; y+=steps){\n                    float2 uv2 = uv + float2(x * offset.x, y * offset.y);\n                    float3 cur_c = tex.sample(sam, uv2).rgb;\n\/\/                    cur_c = highlight(cur_c, -0.5);\n                float para = 1.0 - abs(center_c[i] - cur_c[i]) * 255.0 \/ (2.5 * Y);\n                    sum_i += para * cur_c[i] * 255.0;\n                norm += para;\n                }\n        }\n        sum_c[i] = sum_i \/ norm;\n    }\n    \n     return sum_c \/ 255.0;\n}\n\nhalf GetLuminance(half4 color)\n{\n    return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n}\n\nhalf4 unsharpMask(float amount, float threshold,  half4 pixel,   half4 blurPixel)\n{\n   \n    float lumDelta = abs(GetLuminance(pixel) - GetLuminance(blurPixel));\n    \n    if (lumDelta >= threshold)\n        pixel = pixel + (pixel - blurPixel) * amount;\n    \n    return pixel;\n}\n\n\n\nfloat4 sharpen(float2 uv,texture2d<float> tex,float2 res,float2 nmp ){\n    \n    constexpr sampler samp(filter::linear,address::repeat);\n    \n    float2 nppd = 1.0\/res.xy * 1.0;\n    \n    \n    \n    float4 c = float4(0.0);\n    \n    float4 tl = tex.sample(samp , uv + nppd * float2( -1.0, -1.0));\n    float4 tc = tex.sample(samp , uv + nppd * float2(  0.0, -1.0));\n    float4 tr = tex.sample(samp , uv + nppd * float2(  1.0, -1.0));\n    float4 ml = tex.sample(samp , uv + nppd * float2( -1.0,  0.0));\n    float4 mc = tex.sample(samp , uv + nppd * float2(  0.0,  0.0));\n    float4 mr = tex.sample(samp , uv + nppd * float2(  1.0,  0.0));\n    float4 bl = tex.sample(samp , uv + nppd * float2( -1.0,  1.0));\n    float4 bc = tex.sample(samp , uv + nppd * float2(    0.0,  1.0));\n    float4 br = tex.sample(samp , uv + nppd * float2(  1.0,  1.0));\n    \n    float4 dx = mc-ml;\n    float4 dy = mc-tc;\n    float4 d = (dx + dy) * 0.5;\n    \n    float sharpness = nmp.x * 10.0;\n    c = mc - d * sharpness;\n    \n    return c;\n}\n\nfloat2 computeUV( float2 uv, float k, float kcube ){\n    \n    float2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n    float f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    float2 nUv = f * t + .5;\n    \/\/nUv.y = 1. - nUv.y;\n \n    return nUv;\n    \n}\n\n\n half3 chromatic_aberrationPrevious(float2 uv,texture2d<half> blurred,texture2d<half> tex,float2 res,float nmp ){\n\n\n    constexpr sampler sam(filter::linear);\n     half3 col = half3(0.0);\n     float2 u_resolution = float2(tex.get_width(),tex.get_height());\n     float amount = length(uv-0.5);\n\n            amount = smoothstep(0.0,1.0,amount)*nmp;\n     float blurVal = length(uv-0.5);\n      blurVal = smoothstep(0.0,1.0,blurVal)*nmp*1.5;\n            amount *= nmp;\n             uv -= 0.5;\n            uv \/= 1.0 + nmp\/50.;\n             uv += 0.5;\n            float2 uvRG = uv;\n            uvRG -= 0.5;\n            uvRG \/= 1.0 + amount\/50.;\n            uvRG += 0.5;\n             float2 uvGB = uv;\n            uvGB -= 0.5;\n            uvGB *= 1.0 + amount\/50.;\n            uvGB += 0.5;\n           \n            \n            half3 coll = tex.sample(sam,uvRG).rgb * half3(1.0,0.5,0.0);\n            half3 colR = tex.sample(sam,uvGB).rgb * half3(0.0,0.5,1.0);\n            half3 collBlurred = blurred.sample(sam,uvRG).rgb * half3(1.0,0.5,0.0);\n            half3 colRBlurred = blurred.sample(sam,uvGB).rgb * half3(0.0,0.5,1.0);\n            coll = mix(coll,collBlurred , blurVal) ;\n            colR = mix(colR, colRBlurred, blurVal) ;\n\n\n\n          col += coll;\/\/mix(colR,coll,0.5);\n          col += colR;\n     col = mix(tex.sample(sam,uvRG).rgb, col, nmp\/1.6) ;\n     \n\/\/            col \/= 2.0;\n\/\/         float alpha = tex.sample(sam, uv ).a;\n          \n\n     return half3(col);\n}\n\/\/float blur = 0.05;\n\/\/float falloff = 3.0;\n\/\/half3 chromatic_aberrationPrevious(float2 uv,texture2d<float> blurred,texture2d<float> tex,float2 res,float nmp ){\nhalf4 chromatic_aberration(float2 uv,texture2d<half>  image,float value) {\n\/\/              var inputBlur: CGFloat = 10\n\/\/                var inputFalloff: CGFloat = 0.2\n\/\/                var inputSamples: CGFloat = 10\n              \n              float sampleCount = 10.0;\n    int sampleCountInt = int(floor(sampleCount));\n    half4 accumulator = half4(0.0);\n     float2 res = float2(image.get_width(),image.get_height());\n              float2 size = res;\n              float adaptiveValue = res.y\/1080.;\n            \n\/\/            adaptiveValue *= value;\n    \n              float blur = 3. * adaptiveValue;\n              float start = 0.05 * adaptiveValue;\n              \n    float2 dc = uv*res;\n    float normalisedValue = length(((dc \/ size) - 0.5) * 2.0);\n    float strength = clamp((normalisedValue - start) * (1.0 \/ (1.0 - start)), 0.0, 1.0);\n    strength *= value;\n    float2 vector = normalize((dc - (size \/ 2.0)) \/ size);\n    float2 velocity = vector * strength * blur;\n            \n    float2 redOffset = -vector * strength * (blur * 1.0);\n    float2 greenOffset = -vector * strength * (blur * 1.5);\n    float2 blueOffset = -vector * strength * (blur * 2.0);\n\n    for (int i=0; i < sampleCountInt; i++) {\n        accumulator.r += image.sample(sam, ( dc + redOffset) \/ res).r;\n        redOffset -= velocity \/ sampleCount;\n\n        accumulator.g += image.sample(sam,  ( dc + greenOffset) \/ res).g;\n        greenOffset -= velocity \/ sampleCount;\n\n        accumulator.b += image.sample(sam, (  dc + blueOffset) \/ res).b;\n        blueOffset -= velocity \/ sampleCount;\n    }\n\n    return half4(half3(accumulator \/ half(sampleCountInt)), 1.0);\n}\n\n\nhalf4 overlay(half4 base, half4 blend) {\n    half4 x = half4(2.0) * base * blend;\n    half4 y = half4(1.0) - half4(2.0) * (half4(1.0) - base) * (half4(1.0) - blend);\n    return mix(x, y, step(0.5, base));\n}\n\nhalf4 chromatic_aberrationLut(float2 uv,texture2d<half>  image,float value,    texture2d<half>  lut,float lutIntensity) {\n\/\/              var inputBlur: CGFloat = 10\n\/\/                var inputFalloff: CGFloat = 0.2\n\/\/                var inputSamples: CGFloat = 10\n              \n              float sampleCount = 10.0;\n    int sampleCountInt = int(floor(sampleCount));\n    half4 accumulator = half4(0.0);\n     float2 res = float2(image.get_width(),image.get_height());\n              float2 size = res;\n              float adaptiveValue = res.y\/1080.;\n            \n\/\/            adaptiveValue *= value;\n    \n              float blur = 3. * adaptiveValue;\n              float start = 0.05 * adaptiveValue;\n              \n    float2 dc = uv*res;\n    float normalisedValue = length(((dc \/ size) - 0.5) * 2.0);\n    float strength = clamp((normalisedValue - start) * (1.0 \/ (1.0 - start)), 0.0, 1.0);\n    strength *= value;\n    float2 vector = normalize((dc - (size \/ 2.0)) \/ size);\n    float2 velocity = vector * strength * blur;\n            \n    float2 redOffset = -vector * strength * (blur * 1.0);\n    float2 greenOffset = -vector * strength * (blur * 1.5);\n    float2 blueOffset = -vector * strength * (blur * 2.0);\n\n    for (int i=0; i < sampleCountInt; i++) {\n       \n        float2 uvR = ( dc + redOffset) \/ res;\n        \n        half4 r = image.sample(sam, uvR);\n        r = lutMix(r, uvR, lut,  lutIntensity);\n        accumulator.r += r.r;\n        redOffset -= velocity \/ sampleCount;\n\n        float2 uvG = ( dc + greenOffset) \/ res;\n        \n        half4 g = image.sample(sam, uvG);\n        g = lutMix(g, uvG, lut,  lutIntensity);\n        accumulator.g += g.g;\n        greenOffset -= velocity \/ sampleCount;\n\n        float2 uvB = ( dc + blueOffset) \/ res;\n        half4 b = image.sample(sam, uvB);\n        b = lutMix(b, uvB, lut,  lutIntensity);\n        accumulator.b += b.b;\n        blueOffset -= velocity \/ sampleCount;\n    }\n\n    return half4(half3(accumulator \/ half(sampleCountInt)), 1.0);\n}\n\n\n\nhalf4 applyEffects(int type,float strength, MetalUniform values,\n                    texture2d<half>  sourceTexture,\n                   half4 blured,\n                   half4 halation,\n                   texture2d<half>  lut,\n                    float2 uv,\n                   half4 camCol,bool lutAfter){\n    \n    \n    \/\/MARK: EFFECTS\n    constexpr metal::sampler samNMain(metal::filter::linear,address::clamp_to_edge);\n    \n    \n    \/\/MARK: NONE\n    if(type == 0){\n        return camCol;\n    }else if(type == 1){\n        \/\/MARK: UNSHARP MASK\n     \n        camCol = mix(camCol, unsharpMask(1.4,0.0, camCol, blured), strength);\n\/\/        camCol =  lutMix(camCol, uv, lut,  values.lutIntesity);\n    }else if(type == 2){\n        \/\/MARK: FILM BLUR\n        float adaptiveValue = sourceTexture.get_height()\/1080.;\n        camCol.rgb = blur(sourceTexture,uv,strength*2*adaptiveValue);\n\/\/        if(values.lutBefore == 1){\n        if(!lutAfter){\n            camCol =  lutMix(camCol, uv, lut,  values.lutIntesity);\n        }\n\/\/        }\n       \n    }else if(type == 3){\n        \/\/MARK: white_halation\n       \n        camCol.rgb = screen(halation.rgb, camCol.rgb) * strength + camCol.rgb * (1.0 - strength);\n        \/\/MARK: red_halation\n    }else if(type == 4){\n\/\/        camCol.rgb = halation.rgb;\n        camCol.rgb = screen(halation.rgb*half3(1.0,0.0,0.0), camCol.rgb) * strength + camCol.rgb * (1.0 - strength);\n        \/\/            camCol \/= 1.3\n        \/\/MARK:  SOFT\n    }else if(type == 5){\n  \n        half4 colBefore = camCol;\n        camCol += blured*0.5;\n        camCol \/= 1.5;\n\/\/        colBefore.r = 1.0;\n        camCol = mix(colBefore,camCol, strength);\n        \n        \/\/MARK: sharpen\n    }else if(type == 6){\n        half3 edge = clamp(( blured.rgb - camCol.rgb),0.,1.0);\n        float a = edge.r + edge.g + edge.b;\n        \n        camCol.rgb \/= 1 + half3(a)*strength;\n        \/\/MARK: chromatic_aberration\n    }else if(type == 7){\n        \n       \n\/\/        if(values.lutBefore == 1){\n        if(!lutAfter){\n            camCol.rgb = chromatic_aberrationLut(uv, sourceTexture,strength ,lut,values.lutIntesity).rgb;\n        }else{\n            camCol.rgb = chromatic_aberration(uv, sourceTexture,strength ).rgb;\n        }\n\/\/        }\n    }else if(type == 8){\n        if(!lutAfter){\n            blured = lutMix(camCol, uv, lut,  values.lutIntesity);\n        }\n        return blured;\n    }\n    \/\/MARK: EFFECTS\n    return camCol;\n}\n\n\n\nconstexpr metal::sampler samMain(metal::filter::linear, address::clamp_to_edge);\nconstexpr metal::sampler samNMain(metal::filter::linear,address::clamp_to_edge);\n\nkernel void demo_kernel(texture2d<float, access::sample> input [[texture(0)]],\n                        texture2d<float, access::write> output [[texture(1)]],\n                        texture2d<float, access::sample> lut [[texture(2)]],\n                        texture2d<float, access::sample> bluredTexture [[texture(3)]],\n                        texture2d<float, access::sample> frameTexture [[texture(4)]],\n                        texture2d<float, access::sample> halationTexture [[texture(5)]],\n                        array<texture2d<float, access::sample>, 15> overlays [[texture(22)]],\n                        constant bool &photo [[buffer(7)]],\n                        constant bool &addFrame [[buffer(8)]],\n                        \n                        constant EffectUniforms *effects [[buffer(11)]],\n                        constant MetalUniform &values [[buffer(12)]],\n                        constant OverlayUniforms *overlayBuffers [[buffer(13)]],\n                        uint2 gid [[thread_position_in_grid]]) {\n     \n    float2 res = float2(input.get_width(), input.get_height());\n    float2 resLut = float2(lut.get_width(), lut.get_height());\n    float2 uv = float2(gid.x,gid.y) \/ res;\n    float2 uvLut = float2(gid.x,gid.y) \/ resLut;\n\n        output.write(float4(0.0), gid);\n}\n\n\nkernel void main_kernel(\n                   texture2d<half, access::sample> input [[texture(0)]],\n                   texture2d<half, access::write> output [[texture(1)]],\n                        texture2d<half, access::sample> lut [[texture(2)]],\n                        texture2d<half, access::sample> bluredTexture [[texture(3)]],\n                        texture2d<half, access::sample> frameTexture [[texture(4)]],\n                        texture2d<half, access::sample> halationTexture [[texture(5)]],\n                        constant bool &photo [[buffer(7)]],\n                        constant bool &lutAfter [[buffer(8)]],\n                        constant EffectUniforms *effects [[buffer(11)]],\n                        constant MetalUniform &values [[buffer(12)]],\n                        constant OverlayUniforms *overlayBuffers [[buffer(13)]],\n                        array<texture2d<half, access::sample>, 3> overlays [[texture(22)]],\n                   uint2 gid [[thread_position_in_grid]])\n{\n     \n    float2 res = float2(input.get_width(), input.get_height());\n    \n    float2 uv = float2(gid.x,gid.y) \/ res;\n\n\n    float2 overlayUV = uv;\n    if (photo){\n        overlayUV = overlayUV.yx;\n    }\n    \n    half4 camCol = input.sample(samNMain, uv,level(5));\n    half4 frameCol = frameTexture.sample(samNMain, overlayUV);\n    float2 cvUV = uv;\n    cvUV.y = 1.0 - cvUV.y;\n    half4 halation = halationTexture.sample(samNMain, cvUV);\n\n    half4 blured = half4(0.0);\n    blured = bluredTexture.sample(samNMain, uv);\n   \n    if(!lutAfter){\n        camCol =  lutMix(camCol, uv, lut,  values.lutIntesity);\n    }\n    \/\/MARK: EFFECTS\n    for(int i = 0; i < values.filtersCount; i++){\n        camCol = applyEffects(effects[i].type,effects[i].strength, values, input, blured, halation, lut, uv, camCol,lutAfter);\n    }\n    \/\/MARK: EFFECTS\n    \n        for(int i = 0; i < values.overlaysCount; i++){\n            \n            half4 overlay = overlays[i].sample(samNMain, overlayUV);\/\/*overlayBuffers[i].overlayStrength;\n            \n            camCol.rgb = blend( overlay.rgb\/**overlay.a*\/, camCol.rgb, overlayBuffers[i].overlayBlendMode) * overlayBuffers[i].overlayStrength + camCol.rgb * (1.0 - overlayBuffers[i].overlayStrength);\n            \n        }\n        \n    \n\/\/\n    if(lutAfter){\n        camCol =  lutMix(camCol, uv, lut,  values.lutIntesity);\n    }\n    if (gid.x >= output.get_width() || gid.y >= output.get_height()) {\n           return;\n       }\n        output.write(camCol, gid);\n}\n\n\n\n\nconstexpr metal::sampler double_sam(metal::filter::linear,address::clamp_to_zero);\nfloat2 adjustUV(float2 uv, float2 source_res,float2 main_resolution){\n    \n    \n    \n\n    \n    float aspectMain = main_resolution.y\/main_resolution.x;\n    float aspectSource = source_res.y\/source_res.x;\n\n            if(aspectSource <= aspectMain){\n                uv -= 0.5;\n                uv.x *= aspectSource;\n                uv.x \/= aspectMain;\n                uv += 0.5;\n            }else{\n                uv -= 0.5;\n                uv.y \/= aspectSource;\n                uv.y *= aspectMain;\n                uv += 0.5;\n            }\n\/\/\n    return uv;\n}\n#define pi 3.14159265358979\nkernel void double_exp(\n                   texture2d<float, access::sample> backgrTexture [[texture(0)]],\n                       texture2d<float, access::sample> foregrTexture [[texture(1)]],\n                   texture2d<float, access::write> output [[texture(2)]],\n                       constant bool &photo [[buffer(7)]],\n                       constant int &orientation [[buffer(8)]],\n                   uint2 gid [[thread_position_in_grid]]\n                   \n                        )\n{\n     \n     float2 resBack = float2(backgrTexture.get_width(), backgrTexture.get_height());\n    float2 resFore = float2(foregrTexture.get_width(), foregrTexture.get_height());\n    \n    float aspectRF = 1.0;\n    float aspectRB = 1.0;\n    float scale = 1.0;\n \n    \n    bool horizontal = false;\n    if(resBack.x > resBack.y){\n        horizontal = true;\n    }\n    bool foreHorizontal = false;\n    if(resFore.x > resFore.y){\n        foreHorizontal = true;\n    }\n    \n     float2 uvB = float2(gid.x,gid.y) \/ resBack;\n    float2 uvF = uvB;\/\/float2(gid.x,gid.y) \/ resFore;\n    \n\/\/\n    \n    if(foreHorizontal != horizontal){\n\/\/        uvF -= 0.5;\n        if(foreHorizontal){\n\/\/            uvF.y = 1.0 - uvF.y;\n        }else{\n\/\/            uvF.x = 1.0 - uvF.x;\n        }\n\/\/        uvF = uvF.yx;\n        uvF -= 0.5;\n        uvF = rotateUV(uvF, pi\/2.0 * orientation);\n        uvF += 0.5;\n        if (!foreHorizontal){\n\/\/            uvF.y = 1.0 - uvF.y;\n        }\n\/\/        uvF += 0.5;\n    }\n    if (!photo){\n        if(!foreHorizontal){\n            uvF.y = 1.0 - uvF.y;\n        }else{\n            uvF.x = 1.0 - uvF.x;\n        }\n        \n    }\n    if (foreHorizontal){\n        if (photo){\n\/\/            uvF.y = 1.0 - uvF.y;\n        }\n    }\n\n    \n\/\/\n\/\/    if(resBack.x < resBack.y){\n\/\/        uvB -= 0.5;\n\/\/        uvB = rotateUV(uvB, pi\/2.0);\n\/\/        uvB += 0.5;\n\/\/    }\n    \n\/\/    source_res *= rotate(a);\n    \n\/\/    if(a > 0){\n\/\/        uv.y = 1.0 - uv.y;\n\/\/    }\n    \n     float4 colorBack = backgrTexture.sample(double_sam, uvB).rgba;\n    \n\/\/    uvB = adjustUV(uvB, resFore, resBack);\n   \n    \n    float4 colorFore = foregrTexture.sample(double_sam, uvF).rgba;\n\n    colorBack += colorFore;\n    colorBack \/= 2.0;\n\/\/    if(horizontal){\n\/\/        colorBack.r = 1.0;\n\/\/    }\n    \n     output.write(colorBack, gid);\n}\n\n\nfloat hashh21(float2 p)  \/\/ replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + float2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n\/\/MARK: MATH\nfloat hash21(float2 p) {\n    return fract(sin(dot(p.xy,\n                         float2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat rand11(float p)\n{\n    return fract(cos(p * 31.32) * 3758.5357);\n}\n\nfloat noise11(float p)\n{\n     float fl = floor(p);\n     return mix(rand11(fl), rand11(fl + 1.0), smoothstep(0.0, 1.0, fract(p)));\n}\n\n\n\/\/MARK: MATH\nfloat noise( float2 p )\n{\n    \n    float2 i = floor( p );\n    float2 f = fract( p );\n    float2 u = f*f*(3.0-2.0*f);\n    return mix( mix(hashh21( i + float2(0.0,0.0) ),\n                    hashh21( i + float2(1.0,0.0) ), u.x),\n                mix(hashh21( i + float2(0.0,1.0) ),\n                    hashh21( i + float2(1.0,1.0) ), u.x), u.y)*0.5 + 0.5;\n\n}\n\nfloat perlinNoise(float2 uv){\n    float2x2 m = float2x2( 1.6,  1.2, -1.2,  1.6 );\n   float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n\nfloat3 colorGrain(float2 noiseUV,float u_t){\n\n     float3 noiseCol = float3(0.0);\n    noiseCol.r  = noise(float2(noiseUV.x + sin(u_t*2. )*2.,noiseUV.y + sin(u_t*3. )*2.)*1100.);\n    noiseCol.g  = noise(float2(noiseUV.x + sin(u_t*2. )*2.,noiseUV.y + sin(u_t\/2. )*2.)*1100.);\n    noiseCol.b  = noise(float2(noiseUV.x + sin(u_t*2. )*2.,noiseUV.y + sin(u_t*1.2)*2.)*1100.);\n    noiseCol += 0.05;\n    return noiseCol;\n}\nfloat3 bwGrain(float2 noiseUV,float u_t){\n\n     \n    float noiseBw  = noise(float2(noiseUV.x + sin(u_t*2. )*2.,noiseUV.y + sin(u_t*3. )*2.)*1100.);\n    \n    \n    return float3(noiseBw);\n}\n\n\n\nvertex VertexOut vertex_shader(constant VertexIn* vertexArray [[buffer(0)]], unsigned int vid [[vertex_id]]) {\n     \n     VertexIn vertexData = vertexArray[vid];\n     VertexOut vertexDataOut;\n     vertexDataOut.position = float4(vertexData.position.x, vertexData.position.y, 0.0, 1.0);\n     vertexDataOut.textureCoorinates = vertexData.textureCoorinates.xy;\n     return vertexDataOut;\n}\nfragment float4 frag_prefilter(VertexOut fragmentIn [[stage_in]],\n                               texture2d<float, access::sample> video [[texture(0)]]){\n    constexpr sampler sam(mag_filter::linear, min_filter::linear);\n    float2 uv = fragmentIn.textureCoorinates;\n    float2 size = float2(video.get_width(),video.get_height());\n    const float vscale = 1.5;\n    const float dy =  vscale \/ 2.0;\n\n    float3 c0 = video.sample(sam,float2(uv.x, uv.y - 0.001)).rgb;\n    float3 c1 = video.sample(sam,float2(uv.x, uv.y + 0.001)).rgb;\n    float3 c = (c0 + c1) \/ 2.0;\/\/float3(blur(video, uv, 2.));\/\/\n\n    float br = max(c.r, max(c.g, c.b));\n    c *= max(0.0, br - 0.6) \/ max(br, 1e-5);\n    \n    return float4(c, 1.0);\n}\nfragment float4 firstFlamesPass(VertexOut fragmentIn [[stage_in]],\n                       texture2d<half, access::sample> v [[texture(0)]],\n                       texture2d<float, access::sample> cam [[texture(2)]],\n                       constant float &iteration [[buffer(3)]]) {\n     float2 res = float2(v.get_height(),v.get_width());\n     float2 uv = fragmentIn.textureCoorinates;\n    constexpr metal::sampler samFlare(metal::filter::nearest,address::clamp_to_zero);\n     \/\/uv.y*=res.x\/res.y;\n     float2 gid = uv * float2(res);\n \n\/\/    float2 uvMR = float2(  uv.x + 0.001 ,uv.y  ) ;\n\/\/    float2 uvML = float2(  uv.x - 0.001 ,uv.y  ) ;\n\/\/    float3 colR = v.sample(samFlare, uvMR).rgb;\n\/\/    float3 colL = v.sample(samFlare, uvML).rgb;\n\/\/    float3 camm = cam.sample(samFlare, uv ).xyz;\n\/\/\/\/    camm = float3(dot(camm, float3(.2126, .7152, .0722)));\n\/\/\/\/    camm = smoothstep(0.4, 0.6, camm);\n\/\/    colR = max(colR, camm);\n\/\/    colR = max(colL, colR);\n    \n    float2 uv1 = float2(  uv.x + 0.05 ,uv.y  ) ;\n    float3 col1 = float3(blur(v, uv1, 1.1));\/\/     v.sample(samFlare, uv1).rgb;\n    \n    float2 uv2 = float2(  uv.x - 0.06 ,uv.y  ) ;\n    float3 col2 = float3(blur(v, uv2, 1.1));\n    \n    float3 camm = cam.sample(samFlare, uv ).xyz;\n\/\/    camm = float3(dot(camm, float3(.2126, .7152, .0722)));\n\/\/    camm = smoothstep(0.4, 0.6, camm);\n\/\/    col = max(col, camm);\n    float3 c3 = (col1 + col2) \/ 1.88;\n\/\/    c3 *= 1.0 + noise(uv.yy*112.)\/12.;\n    float3 col = mix(c3, camm,  0.025 );\n  return float4(col,1.0);\n}\nfragment float4 anamorpic_frag_composite(VertexOut fragmentIn [[stage_in]],\n                                texture2d<float, access::sample> flares [[texture(0)]],\n                                texture2d<float, access::sample> photo [[texture(1)]])\n{\n    float2 uv = fragmentIn.textureCoorinates;\n\/\/    uv.y = 1.0 - uv.y;\n    float strength = 0.5;\n    float4 colFlares = flares.sample(sam, uv);\n    float4 colPhoto = photo.sample(sam, fragmentIn.textureCoorinates);\n    colFlares = ( contrastMatrix( 1 + 0.19) * colFlares).rgba;\n\/\/    colPhoto = screen(colFlares, colPhoto) * strength + colPhoto * (1.0 - strength);\n\/\/    colPhoto.rgb = screen(colFlares.rgb, colPhoto.rgb) * strength + colPhoto.rgb * (1.0 - strength);\n\/\/    float3 a3 = photo.sample(sam, fragmentIn.textureCoorinates.yy).rgb;\n    float a = (colPhoto.r + colPhoto.g + colPhoto.b);\n    colFlares.rgb *= (0.5 + noise(float2(a + uv.yy)*112.)\/12.);\n    colFlares = clamp(colFlares, 0.0, 1.0);\n\/\/    colPhoto.rgb += colFlares.rgb;\n    colPhoto.rgb = float3(screen(half3(colFlares.rgb), half3(colPhoto.rgb)));\n    return (colPhoto);\n}\n\n\n\n\n\n\n\n\n\/\/fragment float4 burn(VertexOut fragmentIn [[stage_in]],\n\/\/                           texture2d<half, access::sample> inputTexture [[texture(0)]],\n\/\/                        texture2d<half, access::sample> cam [[texture(1)]],\n\/\/                     constant MetalUniforms &values [[buffer(12)]]){\n\/\/\n\/\/\n\/\/     float2 uv = fragmentIn.textureCoorinates;\n\/\/float tt = values.u_time;\n\/\/    uv -= 0.5;\n\/\/    uv *= r2d(values.transform);\n\/\/    uv += 0.5;\n\/\/\/\/    if(mirr){\n\/\/\/\/     uv.x = 1.-uv.x;\n\/\/\/\/    }\n\/\/     float3 col = float3(inputTexture.sample(sam, (uv) ).xyz);\n\/\/     float4 coll = float4(cam.sample(sam, uv ));\n\/\/    float4 color = float4(pow(col, float3(0.4545)),1.0);\n\/\/     float2 uvv = uv;\n\/\/\/\/     uvv+=1.5;\n\/\/\/\/     float2 g = uvv*res;\n\/\/     coll+=color;\n\/\/    \/\/coll.rgb+=sparkles(uv*res,time,res);\n\/\/     uvv.y+=1.;\n\/\/     \/\/uvv*=2.;\n\/\/\n\/\/\n\/\/\n\/\/\n\/\/     return float4(float3(coll.rgb),1.0);\n\/\/\n\/\/}\n\n\n\n\n\n\/\/\n\/\/\/\/ Downsampler\n\/\/ Downsampler\nfragment float4 frag_down(VertexOut fragmentIn [[stage_in]],\n                           texture2d<float, access::sample> video [[texture(0)]])\n{\n    constexpr sampler sam(mag_filter::linear, min_filter::linear);\n    \n    \n    float2 size = float2(video.get_width(),video.get_height());\n    float texelSize = 1.0 \/ size.x;\n\n    const float hscale = 1.25;\n      const float dx = texelSize * hscale;\n\n    float u0 = fragmentIn.textureCoorinates.x - dx * 5.0;\n    float u1 = fragmentIn.textureCoorinates.x - dx * 3.0;\n    float u2 = fragmentIn.textureCoorinates.x - dx * 1.0;\n    float u3 = fragmentIn.textureCoorinates.x + dx * 1.0;\n    float u4 = fragmentIn.textureCoorinates.x + dx * 3.0;\n    float u5 = fragmentIn.textureCoorinates.x + dx * 5.0;\n\n    float3 c0 = video.sample(sam,float2(u0, fragmentIn.textureCoorinates.y)).rgb;\n    float3 c1 = video.sample(sam,float2(u1, fragmentIn.textureCoorinates.y)).rgb;\n    float3 c2 = video.sample(sam,float2(u2, fragmentIn.textureCoorinates.y)).rgb;\n    float3 c3 = video.sample(sam,float2(u3, fragmentIn.textureCoorinates.y)).rgb;\n    float3 c4 = video.sample(sam,float2(u4, fragmentIn.textureCoorinates.y)).rgb;\n    float3 c5 = video.sample(sam,float2(u5, fragmentIn.textureCoorinates.y)).rgb;\n\n    float3 c = (c0 + c1 + c2 + c3 + c4 + c5) \/ 6.0;\n\n    return float4(c, 1.0);\n}\n\n\n#define _Color float3(0.5, 0.5, 0.7)\n#define _Intensity 1.0\n\n\/\/ Upsampler\nfragment float4 frag_up(VertexOut fragmentIn [[stage_in]],\n                         texture2d<float, access::sample> blanc [[texture(0)]],\n                         texture2d<float, access::sample> highTex [[texture(1)]])\n{\n   \n\/\/    texelX * hscale;\n    const float stretch = 0.01;\n    float2 uv = fragmentIn.textureCoorinates;\n    float3 c0 = blanc.sample(sam, fragmentIn.textureCoorinates + 0.0001).rgb \/ 4.0;\n    float3 c1 = blanc.sample(sam, fragmentIn.textureCoorinates).rgb \/ 2.0;\n    float3 c2 = blanc.sample(sam, fragmentIn.textureCoorinates).rgb \/ 4.0;\n    float3 c3 = highTex.sample(sam, uv).rgb;\n\n    float3 cf = (c0 + c1 + c2) * _Color * 1.0 * 5.0;\n    float3 sumCol = c0 + c1 + c2;\n    \n    \n\/\/        uv -= 0.5;\n\/\/        uv.x \/= 1.0 + stretch;\n\/\/        uv += 0.5;\n\/\/\n\/\/        float3 buffer = blanc.sample(sam, uv).rgb;\n\/\/        buffer *= 0.98 ;\n\/\/\n\/\/\n\n    \n    return float4(mix(c3, sumCol,  0.9), 1);\n\n}\n\n\/\/ Final composition\n\n\n\nfragment float4 halation_fragment(VertexOut fragmentIn [[stage_in]],\n                      texture2d<float, access::sample> video [[texture(0)]],\n                      texture2d<float, access::sample> halation [[texture(1)]],\n                                  constant bool &orientation [[buffer(10)]]) {\n     \n     constexpr sampler sam(mag_filter::linear, min_filter::linear);\n     float2 uv = fragmentIn.textureCoorinates;\n   \n    \n    \n    float2 hUV = float2(uv.x, 1.0 - uv.y);\n    if (orientation){\n        uv = float2(uv.x, 1.0 - uv.y);\n        hUV = float2(hUV.x, 1.0 - hUV.y);\n    }\n    \n    \n    float3 halatioColor = float3(0.9,0.4,0.27);\n    float3 halatioColorbright = float3(1.0,0.85,0.72);\n    float halationMask = halation.sample(sam,  hUV).r*2.;\n    float3 videoC = video.sample(sam,  uv).rgb;\n    float3 color = videoC;\n    color.gb \/= 1.1;\n    \n    halatioColor = mix(halatioColor, halatioColorbright,halationMask\/2.)*(halationMask*2.);\n    halatioColor = saturation(halatioColor,2.0);\n    color = float3(screen(half3(halatioColor*0.75),half3(color)));\n     return float4(color,1.0);\n   \n}\n\n\nfloat pizza(float2 p, float2 a, float2 b,float2 res){\n    float2 pa = p-a;\n    float2 ba = b-a;\n\n    float t = clamp(dot(pa, ba)\/dot(ba,ba)\/2.,0.,1.0);\n    float2 cv = pa - ba*t;\n    \/\/ cv.y *= res.y\/res.x;\n    float d = length(cv);\n    d = smoothstep(0.0,0.7,d);\n    \/\/ if(distance(a, b)>2.){return 2.;}else{\n    return ( d);\n    \/\/ }\n}\n\n\nfloat3 rgbDisp(texture2d<float> tex, float2 uv, float r,float val){\n\/\/    float R = blur(tex,uv-0.01,r).r;\n\/\/    float G =  blur(tex,uv,r+.2).g;\n    float R = tex.sample(sam,  uv-0.01).r;\n    float G = tex.sample(sam,  uv+float2(0.01,-0.01)).g;\n    float B = tex.sample(sam,  uv+0.01).b;\n\/\/    float R =  blur(tex,uv-0.01,r-.3).b;\n\/\/    float G =  blur(tex,uv+float2(0.01,-0.01),r-.3).b;\n\/\/    float B =  blur(tex,uv+0.01,r-.3).b;\n    float3 col = tex.sample(sam,  uv).rgb;\n    return mix(col,float3(R,G,B),val);\n}\n\n\n\nkernel void kaleida(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 texture2d<float, access::write> cvTexture [[texture(2)]],\n                     constant float3 *fcBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                   uint2 gid [[thread_position_in_grid]])\n{\n    float effectValue = 0.5;\n     float4 fragColor = float4(0.0);\n    float tt = 112.123;\n    float2 res = float2(input.get_width(), input.get_height());\n    float2 uv = float2(gid.x,gid.y) \/ res;\n    \n\/\/    float3 maskCol = maskTex.sample(sam,  uv).rgb;\n    float3 pc[4];\n        pc[0] = float3(0.0,1.0,0.87);\n        pc[1] = float3(0.367, 0.0, 1.0);\n        pc[2] = float3(1.0,0.023,0.0);\n        pc[3] = float3(1.0,0.8,0.0);\n\/\/      if (orientation){\n\/\/          uv = float2(uv.x, 1.0 - uv.y);\n\/\/      }\n    float u_time =  pi\/3.;\n    float2 pUV = uv - 0.5;\n    float2 u_resolution = res;\n\/\/    if(mirr){\n\/\/     uv.x = 1.-uv.x;\n\/\/    }\n     constexpr sampler sam(filter::linear);\n     \n     \n    \n    float3 color = 0.0;\/\/input.sample(sam, float2(uv.x,uv.y) ).rgb;\n    float3 col = 0.0;\/\/input.sample(sam, float2(uv.x,uv.y) ).rgb;\/\/color;\n    \n    \n    float rad = 0.9 ;\n    float3 p0 = float3(rad * sin(u_time\/1.2-pi\/2.), rad * cos(u_time\/1.2-pi\/2.), 0.1);\n    float3 p1 = float3(rad * sin(u_time\/1.2+pi\/2.), rad * cos(u_time\/1.2+pi\/2.), 0.1);\n    float3 p2 = float3(rad * sin(u_time\/1.2+pi), rad * cos(u_time\/1.2+pi), 0.1);\n    float3 p3 = float3(rad * sin(u_time\/1.2-pi*2.0), rad * cos(u_time\/1.2-pi*2.), 0.1);\n    pUV*=4.0;\n    float4 d = float4(0.0);\n    float scale = 9.0;\n    d.r += pizza(pUV\/scale,p0.xy,float2(0.0),u_resolution.xy);\n    d.g += pizza(pUV\/scale,p1.xy,float2(0.0),u_resolution.xy);\n    d.b += pizza(pUV\/scale,p2.xy,float2(0.0),u_resolution.xy);\n    d.a += pizza(pUV\/scale,p3.xy,float2(0.0),u_resolution.xy);\n    d.rgba = smoothstep(0.8,.5,d.rgba);\n    \n    float3 colTx = rgbDisp(input,uv - p0.xy\/6.,1.0,mix(0.0,(1.0 - d.r)*2.,effectValue));\/\/texture2D(u_texture_1,uv+0.5 - p0.xy\/6.).rgba;\n    col += colTx.rgb*d.r;\n    colTx.rgb = rgbDisp(input,uv - p1.xy\/6.,1.0,mix(0.0,(1.0 - d.g)*2.,effectValue));\n    col += colTx.rgb*d.g;\n    colTx.rgb = rgbDisp(input,uv - p2.xy\/6.,1.0,mix(0.0,(1.0 - d.b)*2.,effectValue));\n    col += colTx.rgb*d.b;\n    colTx.rgb = rgbDisp(input,uv - p3.xy\/6.,1.0,mix(0.0,(1.0 - d.a)*2.,effectValue));\n    col += colTx.rgb*d.a;\n    \n    uv-=0.5 ;\n    float centerShape = abs(uv.y);\n   centerShape = smoothstep(0.3,.1,centerShape);\n   centerShape *= smoothstep(0.3,.1,abs(uv.x));\n    uv+=0.5;\n    \n    \n    col *= 1.0 - centerShape;\n    colTx.rgb =  rgbDisp(input,uv,1.0,1.0 - centerShape);\n   col += colTx.rgb*centerShape;\n\/\/    col.rgb =  rgbDisp(input,uv,1.0);\n    output.write(float4(col,1.0), gid);\n\/\/     return float4(col, 1.0);\n}\n\nkernel void smootsh(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                   texture2d<float, access::sample> blurredTexture [[texture(3)]],\n                     constant float3 *fcBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                   uint2 gid [[thread_position_in_grid]] ){\n\n    float2 res = float2(input.get_width(), input.get_height());\n    float2 uv = float2(gid.x,gid.y) \/ res;\n                       float3 bCol = blurredTexture.sample(sam, uv).rgb;\n                       \n                       float4 col = input.sample(sam, uv).rgba;\n                       \n                       float3 hpcol = col.rgb - bCol;\n                       \n                       hpcol.rgb = shadows(hpcol,1.0,1.1);\n                       \n                       col.rgb -= hpcol;\n                       \n    output.write(float4(col.rgb,1.0), gid);\n}\n\n\nfloat2 shift(float theta,  float r)\n{\n    r += 1.0 \/ r;\n    return (r-1.0) * float2(cos(theta), sin(theta));\n}\n\n\/\/-------------------------------------------------------------------------------------------\n\n\n\nkernel void bloom(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 texture2d<float, access::sample> blurredTexture [[texture(3)]],\n                     constant float3 *fcBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                   uint2 gid [[thread_position_in_grid]] ){\n                       constexpr sampler sam(filter::linear);\n    float2 res = float2(input.get_width(), input.get_height());\n    float2 uv = float2(gid.x, gid.y) \/ res;\n\n    \n    float3 col = input.sample(sam, uv).rgb;\n\n    float4 colNorm = input.sample(sam, uv);\n    float4 colBlurred = blurredTexture.sample(sam, uv);\n           \n\/\/                       colBlurred = ( brightnessMatrix( 0.1) * colBlurred).rgba;\n                       colBlurred = ( contrastMatrix( 1 + 0.19) * colBlurred).rgba;\n\/\/                       colBlurred.a *= 0.43;\n                       colNorm = float4(softLight( half4(colNorm), half4(colBlurred)))  * 0.43 + colNorm * (1.0 - 0.43);;\n    output.write(float4(colNorm), gid);\n}\n\nkernel void rgb_shift(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 texture2d<float, access::write> cvTexture [[texture(2)]],\n                     constant float3 *fcBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                   uint2 gid [[thread_position_in_grid]] ){\n\n    float2 res = float2(input.get_width(), input.get_height());\n    float2 uv = float2(gid.x, gid.y) \/ res;\n  \n    constexpr sampler sam(filter::linear);\n    float shift = 0.002;\n    float3 col = float3(0.0);\n    uv \/= 1.001;\n    uv.x += shift;\n    col.r = input.sample(sam, uv).r;\n    uv.x -= shift;\n    col.g = input.sample(sam, uv).g;\n    uv.x -= shift;\n    col.b = input.sample(sam, uv).b;\n    \n    output.write(float4(col, 1.0), gid);\n}\n\nkernel void dream(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 texture2d<float, access::sample> blurredTexture [[texture(3)]],\n                     constant float3 *fcBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                   uint2 gid [[thread_position_in_grid]] ){\n\n    float2 res = float2(input.get_width(), input.get_height());\n    float2 uv = float2(gid.x, gid.y) \/ res;\n\n    constexpr sampler sam(filter::linear);\n    \n    float vign = vingette(uv, 0.3, 0.3);\n    float3 colNorm = input.sample(sam, uv).rgb;\n    float3 colBlurred = blurredTexture.sample(sam, uv).rgb;\n    float3 col = mix(colBlurred, colNorm, vign);\n    \n    output.write(float4(col, 1.0), gid);\n}\n\nkernel void mm16(\n                   texture2d<half, access::sample> input [[texture(0)]],\n                   texture2d<half, access::write> output [[texture(1)]],\n                   texture2d<half, access::sample> overlay [[texture(2)]],\n                   constant float3 *fcBuffer [[buffer(8)]],\n                   constant int &count [[buffer(7)]],\n                   uint2 gid [[thread_position_in_grid]] ){\n\n    float2 res = float2(input.get_width(), input.get_height());\n    float2 uv = float2(gid.x, gid.y) \/ res;\n\n    constexpr sampler sam(filter::linear);\n                       half3 col = input.sample(sam, uv).rgb;\n\n    float vign = vingette(uv, res, 0.45, 0.4);\n                       \n                       \n                       half3 blendedCol = blend(vign,col,  14)*( - vign);\n                       col = mix( blendedCol,col, vign);\n    output.write(half4(col, 1.0), gid);\n}\n\nkernel void swirl(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                   texture2d<float, access::sample> cvTexture [[texture(2)]],\n                   constant float3 *fcBuffer [[buffer(8)]],\n                   constant int &count [[buffer(7)]],\n                   uint2 gid [[thread_position_in_grid]] ){\n\n    float2 res = float2(input.get_width(), input.get_height());\n    float2 uv = float2(gid.x, gid.y) \/ res;\n\n    constexpr sampler sam(filter::linear);\n    \n    float vign = vingette(uv, 0.15, 0.2);\n    float3 colNorm = input.sample(sam, uv).rgb;\n    float3 col = radialBlur(input, uv, -0.002, 10);\n    col += radialBlur(input, uv, 0.002, 10);\n    col \/= 2.0;\n    col = mix(col, colNorm, vign);\n    \n    output.write(float4(col, 1.0), gid);\n}\n\nkernel void fisheye(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 texture2d<float, access::sample> cvTexture [[texture(2)]],\n                     constant float3 *fcBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                   uint2 gid [[thread_position_in_grid]] ){\n\n    float2 res = float2(input.get_width(), input.get_height());\n    float2 uv = float2(gid.x,gid.y) \/ res;\n          \n    float vignette = 1.0 - length(uv - float2(0.5)) * 2.0;\n                       \n    constexpr sampler sam(filter::linear);\n    \n    float k = 1.1;\n    float offset = 0.05;\n\/\/                       uv -= 0.5;\n    float2 uvFisheye = uv;\n                       uvFisheye -= 0.5;\n                       uvFisheye \/= 1.3;\n                       uvFisheye += 0.5;\n    float vign = vingette(uv, res, 0.45, 0.08);\n                       offset *= 1.0 - vign + 0.1;\n    float2 r = computeUV(uvFisheye, k + offset);\n    float2 g = computeUV(uvFisheye, k);\n    float2 b = computeUV(uvFisheye, k - offset);\n\/\/                       uv += 0.5;\n\/\/                       r += 0.5;\n\/\/                       g += 0.5;\n\/\/                       b += 0.5;\n   \n\n    float red = input.sample(sam, r).r;\n    float green = input.sample(sam, g).g;\n    float blue = input.sample(sam, b).b;\n    \n    float3 col = float3(red, green, blue) * vign;\n    \n    output.write(float4(col, 1.0), gid);\n}\n\n\n\n\/\/-------------------------------------------------------------------------------------------\nfloat3 bokehSampler(texture2d<float> tex, float2 uv, float radius, float amount, float2 res)\n{\n    float3 acc = float3(0.0);\n    float3 div = float3(0.0);\n    float2 pixel = float2(res.y\/res.x, 1.0) * radius * .006;\n    float r = 1.0;\n    for (float j = 0.0; j < 30.; j += 0.25)\n    {\n           float2 shiftVal =  shift(j, r);\n        float3 col = tex.sample(sam,  uv + pixel * shiftVal).rgb;\n        float3 bokeh = float3(5.0) + pow(col, float3(9.0)) * amount;\n        acc += col * bokeh;\n        div += bokeh;\n    }\n    return acc \/ div;\n}\n\n\nkernel void bokeh( texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n\/\/                   texture2d<float, access::sample> bokehFocusMap [[texture(2)]],\n                   constant float3 *cvBuffer [[buffer(8)]],\n                   constant int &count [[buffer(7)]],\n                   constant bool &photo [[buffer(11)]],\n                   uint2 gid [[thread_position_in_grid]] )\n{\n     \n     float2 res = float2(input.get_width(), input.get_height());\n     \n     float2 uv = float2(gid.x,gid.y) \/ res;\n  \n\n   \n    float a = 50.0;\n    \n    \n    \n    float focusShape = abs(uv.y-0.5);\n    \n    focusShape = smoothstep(0.0,0.4,focusShape);\n    float4 color = float4(bokehSampler(input, uv, focusShape, a,res), 1.0);\n    \/\/ color = float4(focusShape);\n    output.write(color, gid);\n\n}\n\n#define pi 3.14159265358979323846\n\nfloat3 drawGoldenSparkle(float2 uv, float size, float2 position) {\n    float3 color = float3(0.0);\n    float2 p = uv - position;\n    p \/= (size) + 0.01 ;\n    float2 pos = float2(0.5);\n\n    float an = mod(atan2(p.y, p.x) + 6.2831 \/ 3.0, 6.2831 \/ 6.0) - 6.2831 \/ 3.0;\n    p = float2(cos(an), sin(an)) * length(p);\n    \n    float rad = 256.;\/\/mix(150.0,10.,size);\n\/\/    float rad = mix(256.0,56.,size);\n    float br = 250.0 * pow(1.0 \/ max(10.0, rad * (sqrt(abs(p.x)) + sqrt(abs(p.y))) + 0.9), 2.5);\n    color = mix(float3(br, 0.4 * br, 0.0), float3(1.0), br);\n    return color;\n}\nfloat3 starlightSparkle( float2 uv, float size, float2 position) {\n     \n            float3 color = float3(0.0);\n            float2 p = uv - position;\n            p \/= (size) + 0.01 ;\n            float2 pos = float2(0.5);\n\n            float an = mod(atan2(p.y, p.x) + 6.2831 \/ 3.0, 6.2831 \/ 8.0) - 6.2831 \/ 3.0;\n            p = float2(cos(an), sin(an)) * length(p);\n            \n            float rad = 256.;\/\/mix(150.0,10.,size);\n        \/\/    float rad = mix(256.0,56.,size);\n            float br = 250.0 * pow(1.0 \/ max(10.0, rad * (sqrt(abs(p.x)) + sqrt(abs(p.y))) + 0.9), 2.5);\n            color = mix(float3(br, 0.4 * br, 0.0), float3(1.0), br);\n             float glow = length(p);\n             glow = smoothstep(0.025, 0.0, glow)\/4.;\n             color += glow;\n            return color;\n}\nfloat3 drawflare(float2 p, float intensity,  float blur, float glow)\n{\n\n  \n    p = rotateUV(p, pi \/ 4.);  \/\/ rotate sparkle here\n    \n    \n    p *= 2.0;\/\/sparkle scale\n    \n    float lingrad = distance(float2(0.), p); \/\/linear radial gradient\n    float expgrad = 1. \/ exp(lingrad ); \/\/exponential radial gradient\n    float3 colgrad = float3(\n                            hsv2rgb(\n                                    half3( fract( (expgrad * 8.) ), pow(1.-abs(expgrad*2.-1.), 0.45), 210.0 * expgrad * intensity)\n                                    )\n                            ); \/\/rainbow spectrum effect\n    \n    \n    float blades = length(p * sin(2.0 * atan2(p.y, p.x))); \/\/draw 6 blades\n    \n    float comp = pow(1. - saturateF( blades ), 13. - (blur*12.)); \/\/ sharpen effect\n    comp += saturateF((expgrad-0.9)) * 3.;\n    comp = pow(comp * expgrad, 1 + (1.-intensity) * 5.); \/\/ compose and sharpen effect\n    float3 col = float3(comp) * colgrad;\n    float d = length(p);\n    d = smoothstep(intensity\/1. * 3.,intensity\/10. * 2. , d)\/2. * glow;\n    col += d; \/\/ adding a smooth glow effect\n    return  col;\n}\n\n\n\n\n\nkernel void radiant(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 \n                     constant float3 *cvBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                     constant bool &photo [[buffer(11)]],\n                   uint2 gid [[thread_position_in_grid]] )\n{\n     \n     float2 res = float2(input.get_width(), input.get_height());\n     \n     float2 uv = float2(gid.x,gid.y) \/ res;\n  \n    float3 d = float3(0.0);\n\n    for(int i = 0; i < count; i+=1 ){\n   \n        \n        float sparkleSize =  cvBuffer[i].z;\n        float2 sparklePos = cvBuffer[i].xy;\n\n        \/\/flip sparkles position verticaly\n        if (!photo){\n            sparklePos.y = 1.0 - sparklePos.y;\n        }\n\n        sparklePos = uv - sparklePos;\n        if(cvBuffer[i].x != float(0.0)){\n            d += drawflare((sparklePos ),\n                           sparkleSize,\n                           0.5,\n                           0.5);\/\/( float(int(size)) + 1. );\n        }\n\/\/        (float2 p, float intensity,  float speed, int id, float2 res , float blur, float glow)\n    }\n    float4 camCol = input.sample(sam, uv);\n     output.write(float4(camCol.rgb + d,1.0), gid);\n}\n\n\nkernel void golden(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 \n                     constant float3 *cvBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                     constant bool &photo [[buffer(11)]],\n                   uint2 gid [[thread_position_in_grid]] )\n{\n     \n     float2 res = float2(input.get_width(), input.get_height());\n     \n     float2 uv = float2(gid.x,gid.y) \/ res;\n  \n    float3 d = float3(0.0);\n\n    for(int i = 0; i < count; i+=1 ){\n        float spsz = cvBuffer[i].z;\n        spsz = smoothstep(0.0, 1.0, spsz);\n        float sizeOp = cvBuffer[i].z;\/\/ (spsz * 1.5 );\n        float size =  cvBuffer[i].z;\n        float2 sparklePos = cvBuffer[i].xy;\n        \n\/\/\n\/\/        if(photo){\n\/\/            float2 overlayres = float2(480.0, 640.0);\n\/\/            float2 scale = res \/ overlayres;\n\/\/\n\/\/            sparklePos = sparklePos \/ scale;\n\/\/            sparklePos = sparklePos.yx;\n\/\/\n\/\/        }\n        if (!photo){\n            sparklePos.y = 1.0 - sparklePos.y;\n        }\n        \n        if(cvBuffer[i].x != float(0.0)){\n\/\/            d += drawflare((uv - sparklePos )*8, size*2.0, 0.01, values.u_time\/2., i, values.res, 0.5,0.5)\/( float(int(sizeOp * 10.))\/10. + 1. );\n            d += drawGoldenSparkle((uv-sparklePos),size*1000.,float2(0.));\n        }\n    }\n    float4 camCol = input.sample(sam, uv);\n     output.write(float4(camCol.rgb + d,1.0), gid);\n}\n\nkernel void starlight(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 \n                     constant float3 *cvBuffer [[buffer(8)]],\n                     constant int &count [[buffer(7)]],\n                     constant bool &photo [[buffer(11)]],\n                   uint2 gid [[thread_position_in_grid]] )\n{\n     \n     float2 res = float2(input.get_width(), input.get_height());\n     \n     float2 uv = float2(gid.x,gid.y) \/ res;\n  \n    float3 d = float3(0.0);\n\n    for(int i = 0; i < count; i+=1 ){\n        float spsz = cvBuffer[i].z;\n        spsz = smoothstep(0.0, 1.0, spsz);\n        float sizeOp = cvBuffer[i].z;\/\/ (spsz * 1.5 );\n        float size =  cvBuffer[i].z;\n        float2 sparklePos = cvBuffer[i].xy;\n        \n\/\/\n\/\/        if(photo){\n\/\/            float2 overlayres = float2(480.0, 640.0);\n\/\/            float2 scale = res \/ overlayres;\n\/\/\n\/\/            sparklePos = sparklePos \/ scale;\n\/\/            sparklePos = sparklePos.yx;\n\/\/\n\/\/        }\n        if (!photo){\n            sparklePos.y = 1.0 - sparklePos.y;\n        }\n        \n        if(cvBuffer[i].x != float(0.0)){\n\/\/            d += drawflare((uv - sparklePos )*8, size*2.0, 0.01, values.u_time\/2., i, values.res, 0.5,0.5)\/( float(int(sizeOp * 10.))\/10. + 1. );\n            d += starlightSparkle((uv-sparklePos),size*1000.,float2(0.));\n        }\n    }\n    float4 camCol = input.sample(sam, uv);\n     output.write(float4(camCol.rgb + d,1.0), gid);\n}\n\n\nkernel void none(\n                   texture2d<float, access::sample> input [[texture(0)]],\n                   texture2d<float, access::write> output [[texture(1)]],\n                 texture2d<float, access::write> cvTexture [[texture(2)]],\n                 \n                   uint2 gid [[thread_position_in_grid]] )\n{\n     \n     float2 res = float2(input.get_width(), input.get_height());\n     \n     float2 uv = float2(gid.x,gid.y) \/ res;\n  \n\n     float4 camCol = input.sample(sam, uv);\n    camCol.r = 1.0;\n     output.write((camCol), gid);\n}\n\""
    }
  ]
}